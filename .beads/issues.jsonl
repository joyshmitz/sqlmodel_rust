{"id":"sqlmodel_rust-0gv","title":"SQLModel Rust: MySQL Protocol Implementation","description":"# Epic: MySQL Protocol Implementation (sqlmodel-mysql)\n\n## Overview\nThis epic implements the MySQL wire protocol from scratch. MySQL uses a different protocol than PostgreSQL but follows similar principles: TCP connection, length-prefixed packets, and request-response patterns.\n\n## Rationale\nSame reasoning as PostgreSQL: full control, native async, cancellation support, and first-principles understanding. MySQL is important for:\n- Huge existing deployments\n- AWS Aurora MySQL\n- MariaDB compatibility\n- Different feature set than PostgreSQL\n\n## Key Components\n\n### 1. Packet Protocol (protocol.rs)\nMySQL uses 4-byte header packets:\n- 3 bytes: payload length\n- 1 byte: sequence number\n- Payload\n\nPackets over 16MB are split. Sequence numbers track request/response pairing.\n\n### 2. Connection Handshake (handshake.rs)\nInitial handshake:\n1. Server sends HandshakeV10:\n   - Protocol version\n   - Server version string\n   - Connection ID\n   - Auth plugin data (salt)\n   - Capability flags\n   - Character set\n   - Status flags\n2. Client sends HandshakeResponse:\n   - Capability flags\n   - Max packet size\n   - Character set\n   - Username, auth response\n   - Database name\n   - Auth plugin name\n\n### 3. Authentication (auth.rs)\nMySQL auth plugins:\n- mysql_native_password: SHA1-based (legacy)\n- caching_sha2_password: SHA256-based (default MySQL 8.0+)\n- sha256_password: RSA-based\n- auth_gssapi_client: Kerberos\n\ncaching_sha2_password flow:\n1. Client sends scrambled password\n2. Server may request full auth (public key exchange)\n3. Client encrypts password with server's public key\n4. Server verifies\n\n### 4. Command Protocol (commands.rs)\nMySQL commands (COM_xxx):\n- COM_QUERY: Text protocol query\n- COM_STMT_PREPARE: Prepare statement\n- COM_STMT_EXECUTE: Execute prepared\n- COM_STMT_CLOSE: Close prepared\n- COM_STMT_RESET: Reset statement\n- COM_PING: Keep-alive\n- COM_QUIT: Close connection\n- COM_INIT_DB: Change database\n- COM_FIELD_LIST: Get columns (deprecated)\n\n### 5. Result Sets (results.rs)\nText protocol results:\n1. Column count packet\n2. Column definition packets (per column)\n3. EOF packet (or OK if no results)\n4. Row packets (length-encoded strings)\n5. EOF packet (end of rows)\n\nBinary protocol results (prepared statements):\n- Similar structure but binary encoding\n- NULL bitmap for nullable columns\n- Type-specific binary encoding\n\n### 6. Type System (types.rs)\nMySQL types to Rust:\n- MYSQL_TYPE_TINY -\u003e i8\n- MYSQL_TYPE_SHORT -\u003e i16\n- MYSQL_TYPE_LONG -\u003e i32\n- MYSQL_TYPE_LONGLONG -\u003e i64\n- MYSQL_TYPE_FLOAT -\u003e f32\n- MYSQL_TYPE_DOUBLE -\u003e f64\n- MYSQL_TYPE_STRING, VARCHAR -\u003e String\n- MYSQL_TYPE_BLOB -\u003e Vec\u003cu8\u003e\n- MYSQL_TYPE_DATE -\u003e date\n- MYSQL_TYPE_DATETIME -\u003e datetime\n- MYSQL_TYPE_JSON -\u003e serde_json::Value\n\nLength-encoded integers:\n- \u003c 251: 1 byte\n- \u003c 2^16: 0xFC + 2 bytes\n- \u003c 2^24: 0xFD + 3 bytes\n- \u003c 2^64: 0xFE + 8 bytes\n\n### 7. Prepared Statements (prepared.rs)\nBinary protocol advantages:\n- No SQL injection (parameters separate)\n- Efficient binary encoding\n- Server-side caching\n- Correct type handling\n\nFlow:\n1. COM_STMT_PREPARE -\u003e statement ID, param count, column count\n2. COM_STMT_EXECUTE with binary parameters\n3. Binary result set\n\n### 8. Error Handling (error.rs)\nERR packet format:\n- 0xFF marker\n- Error code (2 bytes)\n- SQL state marker '#'\n- SQL state (5 bytes)\n- Error message\n\nMap MySQL error codes to meaningful errors.\n\n### 9. Transactions\nMySQL transaction commands:\n- START TRANSACTION\n- COMMIT, ROLLBACK\n- SAVEPOINT, ROLLBACK TO SAVEPOINT\n- SET autocommit = 0/1\n\n### 10. Character Sets\nMySQL character set handling:\n- Connection charset\n- Result charset\n- Collation\n\nDefault to utf8mb4 for full Unicode.\n\n## Key Design Decisions\n1. **Async native**: Use asupersync TCP throughout\n2. **Capability negotiation**: Support both old and new features\n3. **Auth plugin system**: Extensible auth mechanism\n4. **Prepared statement cache**: Reuse prepared statements\n5. **Connection reset**: Use COM_RESET_CONNECTION vs reconnect\n\n## Success Criteria\n- [ ] Connect to MySQL 5.7 and 8.0+\n- [ ] All auth methods work\n- [ ] Text protocol queries\n- [ ] Binary protocol prepared statements\n- [ ] All common types map correctly\n- [ ] Transactions work correctly\n- [ ] Error codes mapped to Rust errors\n- [ ] SSL/TLS connections\n- [ ] Connection pooling integration\n- [ ] MariaDB compatibility\n- [ ] Correct character set handling\n\n## Dependencies\n- sqlmodel-core (Connection trait, Value, Row, Error)\n- asupersync (TCP, cancellation, Budget)\n\n## Estimated Scope\n~2000 lines of protocol implementation\n\n## References\n- MySQL Protocol: https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_PROTOCOL.html\n- MariaDB Protocol: https://mariadb.com/kb/en/clientserver-protocol/","status":"open","priority":2,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:19:14.902857954-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:19:14.902857954-05:00"}
{"id":"sqlmodel_rust-53e","title":"SQLModel Rust: Core Foundation Layer","description":"# Epic: Core Foundation Layer (sqlmodel-core)\n\n## Overview\nThis epic covers the foundational types and traits that all other components build upon. The core layer defines the contract between the ORM layer and database drivers, providing type-safe abstractions for values, rows, connections, and errors.\n\n## Rationale\nIn Python SQLModel, the core types are spread across Pydantic (for validation types) and SQLAlchemy (for database types). In Rust, we consolidate these into a single coherent type system that leverages:\n- Rust's enum system for type-safe value representation\n- Traits for connection abstraction (allowing multiple backends)\n- asupersync's Outcome type for cancellation-aware operations\n\n## Key Design Decisions\n1. **Value enum over dynamic typing**: Unlike Python's runtime type coercion, we use a comprehensive Value enum that covers all SQL types with explicit conversions\n2. **Row as indexed + named access**: Support both positional (index) and named (column) access patterns\n3. **Connection trait with async**: All operations are async and take Cx for structured concurrency\n4. **Error hierarchy**: Typed errors for different failure modes (connection, query, type conversion)\n\n## Success Criteria\n- [ ] All SQL primitive types representable in Value enum\n- [ ] Bidirectional conversion between Rust types and Value\n- [ ] Connection trait supports query, execute, transaction\n- [ ] Full asupersync integration (Cx, Outcome, cancellation)\n- [ ] Comprehensive error types with context\n- [ ] Zero unsafe code in public API\n\n## Dependencies\n- asupersync crate (external)\n- serde for serialization traits\n\n## Estimated Scope\n~1500 lines of core type definitions and trait implementations","status":"open","priority":0,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:16:51.159275429-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:16:51.159275429-05:00"}
{"id":"sqlmodel_rust-53e.1","title":"Core: Implement comprehensive Value enum","description":"# Task: Implement Comprehensive Value Enum\n\n## Context\nThe Value enum is the universal representation for all SQL values in SQLModel Rust. It must support every SQL type we need while maintaining type safety and efficient conversion.\n\n## Current State\nBasic Value enum exists with: Null, Bool, TinyInt, SmallInt, Integer, BigInt, Real, Double, Text, Blob.\n\n## Required Enhancements\n\n### Additional Variants Needed\n```rust\npub enum Value {\n    // Existing\n    Null,\n    Bool(bool),\n    TinyInt(i8),\n    SmallInt(i16),\n    Integer(i32),\n    BigInt(i64),\n    Real(f32),\n    Double(f64),\n    Text(String),\n    Blob(Vec\u003cu8\u003e),\n    \n    // Add these\n    Decimal(String),           // Exact decimal (stored as string for precision)\n    Date(i32),                 // Days since Unix epoch\n    Time(i64),                 // Microseconds since midnight\n    DateTime(i64),             // Microseconds since Unix epoch\n    Timestamp(i64),            // Same as DateTime but with timezone awareness flag\n    TimestampTz(i64, i32),     // Timestamp + timezone offset seconds\n    Interval(i64, i32, i32),   // Microseconds, days, months\n    Uuid([u8; 16]),            // 128-bit UUID\n    Json(String),              // JSON stored as string\n    JsonB(Vec\u003cu8\u003e),            // Binary JSON (PostgreSQL)\n    Array(Vec\u003cValue\u003e),         // Homogeneous array\n    Point(f64, f64),           // 2D point (x, y)\n    Inet(IpAddr),              // IP address\n    MacAddr([u8; 6]),          // MAC address\n}\n```\n\n### Conversion Traits\nImplement From\u003cT\u003e for Value:\n- From\u003cbool\u003e, From\u003ci8\u003e, From\u003ci16\u003e, From\u003ci32\u003e, From\u003ci64\u003e\n- From\u003cf32\u003e, From\u003cf64\u003e\n- From\u003cString\u003e, From\u003c\u0026str\u003e\n- From\u003cVec\u003cu8\u003e\u003e, From\u003c\u0026[u8]\u003e\n- From\u003cOption\u003cT\u003e\u003e where T: Into\u003cValue\u003e\n- From\u003cchrono::NaiveDate\u003e, From\u003cchrono::NaiveDateTime\u003e (feature-gated)\n- From\u003cuuid::Uuid\u003e (feature-gated)\n\n### TryFrom\u003cValue\u003e for types\n- TryFrom\u003cValue\u003e for bool, i8, i16, i32, i64\n- TryFrom\u003cValue\u003e for f32, f64\n- TryFrom\u003cValue\u003e for String\n- TryFrom\u003cValue\u003e for Vec\u003cu8\u003e\n- TryFrom\u003cValue\u003e for Option\u003cT\u003e\n\n### Helper Methods\n```rust\nimpl Value {\n    pub fn is_null(\u0026self) -\u003e bool;\n    pub fn as_i64(\u0026self) -\u003e Option\u003ci64\u003e;\n    pub fn as_f64(\u0026self) -\u003e Option\u003cf64\u003e;\n    pub fn as_str(\u0026self) -\u003e Option\u003c\u0026str\u003e;\n    pub fn as_bytes(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e;\n    pub fn type_name(\u0026self) -\u003e \u0026'static str;\n}\n```\n\n## Testing Requirements\n- Round-trip test: T -\u003e Value -\u003e T for all types\n- Null coercion: Value::Null to Option\u003cT\u003e == None\n- Type mismatch: Correct error when converting incompatible types\n- Edge cases: i64::MAX, f64::INFINITY, empty strings, empty blobs\n\n## Acceptance Criteria\n- [ ] All variants listed above are implemented\n- [ ] From\u003cT\u003e implemented for all common Rust types\n- [ ] TryFrom\u003cValue\u003e implemented with proper errors\n- [ ] Helper methods work correctly\n- [ ] 100% test coverage for conversions\n- [ ] No panics in any conversion path\n\n## Files to Modify\n- crates/sqlmodel-core/src/value.rs\n- crates/sqlmodel-core/src/types.rs (if SqlType needs updates)\n\n## Estimated Effort\n~300 lines of code","status":"closed","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:19:58.203661367-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T12:32:33.638165982-05:00","closed_at":"2026-01-17T12:32:33.638165982-05:00","close_reason":"Complete: Added TryFrom implementations for bool, i8-i64, f32, f64, String, Vec\u003cu8\u003e, serde_json::Value, [u8;16], and Option\u003cT\u003e. Added From implementations for unsigned integers (u8-u64), \u0026[u8], serde_json::Value, and [u8;16]. Added comprehensive test suite with 23 tests covering round-trips, edge cases, and error conditions.","dependencies":[{"issue_id":"sqlmodel_rust-53e.1","depends_on_id":"sqlmodel_rust-53e","type":"parent-child","created_at":"2026-01-17T11:19:58.204826381-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-53e.2","title":"Core: Implement Row with efficient column access","description":"# Task: Implement Row with Efficient Column Access\n\n## Context\nRow represents a database result row. It must support both positional access (by index) and named access (by column name) efficiently, as query results can be large.\n\n## Current State\nBasic Row struct exists with HashMap for columns. Performance may be suboptimal for large result sets.\n\n## Required Enhancements\n\n### Optimized Storage\n```rust\npub struct Row {\n    /// Column values in order\n    values: Vec\u003cValue\u003e,\n    /// Column names (shared across rows in same result set)\n    columns: Arc\u003cColumnInfo\u003e,\n}\n\npub struct ColumnInfo {\n    /// Column names in order\n    names: Vec\u003cString\u003e,\n    /// Name -\u003e index mapping for O(1) lookup\n    name_to_index: HashMap\u003cString, usize\u003e,\n}\n```\n\n### Key Benefits\n1. **Shared column info**: All rows from same query share one ColumnInfo via Arc\n2. **O(1) name lookup**: HashMap for name-to-index\n3. **O(1) index access**: Direct Vec access\n4. **Memory efficient**: No string duplication per row\n\n### API\n```rust\nimpl Row {\n    /// Get value by index (O(1))\n    pub fn get(\u0026self, index: usize) -\u003e Option\u003c\u0026Value\u003e;\n    \n    /// Get value by column name (O(1) via HashMap)\n    pub fn get_named(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Value\u003e;\n    \n    /// Get and convert by index\n    pub fn get_as\u003cT: FromValue\u003e(\u0026self, index: usize) -\u003e Result\u003cT\u003e;\n    \n    /// Get and convert by name\n    pub fn get_named_as\u003cT: FromValue\u003e(\u0026self, name: \u0026str) -\u003e Result\u003cT\u003e;\n    \n    /// Number of columns\n    pub fn len(\u0026self) -\u003e usize;\n    \n    /// Column names iterator\n    pub fn column_names(\u0026self) -\u003e impl Iterator\u003cItem = \u0026str\u003e;\n    \n    /// Values iterator\n    pub fn values(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Value\u003e;\n    \n    /// Iterate as (name, value) pairs\n    pub fn iter(\u0026self) -\u003e impl Iterator\u003cItem = (\u0026str, \u0026Value)\u003e;\n    \n    /// Check if column exists\n    pub fn contains_column(\u0026self, name: \u0026str) -\u003e bool;\n}\n```\n\n### FromValue Trait\n```rust\npub trait FromValue: Sized {\n    fn from_value(value: \u0026Value) -\u003e Result\u003cSelf\u003e;\n}\n\n// Implement for all primitive types\nimpl FromValue for i32 { ... }\nimpl FromValue for String { ... }\nimpl\u003cT: FromValue\u003e FromValue for Option\u003cT\u003e { ... }\n```\n\n## Testing Requirements\n- Index access for valid/invalid indices\n- Name access for valid/invalid names\n- Type conversion success and failure\n- Arc sharing verification (same ColumnInfo instance)\n- Large row handling (100+ columns)\n- Empty row handling\n\n## Acceptance Criteria\n- [ ] Arc\u003cColumnInfo\u003e shared across result set\n- [ ] O(1) index and name access\n- [ ] FromValue implemented for all common types\n- [ ] Proper error messages for missing columns\n- [ ] Proper error messages for type mismatches\n- [ ] Memory efficient for large result sets\n\n## Files to Modify\n- crates/sqlmodel-core/src/row.rs\n\n## Estimated Effort\n~200 lines of code","status":"closed","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:20:14.956239646-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T12:40:50.197042713-05:00","closed_at":"2026-01-17T12:40:50.197042713-05:00","close_reason":"Implemented Row with Arc\u003cColumnInfo\u003e for shared metadata, added with_columns(), column_info(), contains_column(), values() iterator, FromValue for i8/i16/f32/json/uuid. All 34 tests pass.","dependencies":[{"issue_id":"sqlmodel_rust-53e.2","depends_on_id":"sqlmodel_rust-53e","type":"parent-child","created_at":"2026-01-17T11:20:14.957394451-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-53e.3","title":"Core: Define Connection and Transaction traits","description":"# Task: Define Connection and Transaction Traits\n\n## Context\nThe Connection trait is the central abstraction that all database drivers implement. It defines how queries are executed, how transactions work, and how to integrate with asupersync's structured concurrency.\n\n## Current State\nBasic Connection trait exists. Needs refinement for:\n- Better async patterns with asupersync\n- Transaction trait separation\n- Prepared statement support\n- Batch operations\n\n## Required Design\n\n### Connection Trait\n```rust\n/// A database connection capable of executing queries.\n/// \n/// All operations are async and take a Cx context for cancellation/timeout support.\n/// Implementations must be Send + Sync for use across async boundaries.\npub trait Connection: Send + Sync {\n    /// Associated transaction type\n    type Transaction\u003c'conn\u003e: Transaction\u003c'conn\u003e\n    where\n        Self: 'conn;\n    \n    /// Execute a query and return all rows.\n    async fn query(\n        \u0026self,\n        cx: \u0026Cx,\n        sql: \u0026str,\n        params: \u0026[Value],\n    ) -\u003e Outcome\u003cVec\u003cRow\u003e, Error\u003e;\n    \n    /// Execute a query and return the first row, if any.\n    async fn query_one(\n        \u0026self,\n        cx: \u0026Cx,\n        sql: \u0026str,\n        params: \u0026[Value],\n    ) -\u003e Outcome\u003cOption\u003cRow\u003e, Error\u003e;\n    \n    /// Execute a query and stream rows one at a time.\n    async fn query_stream(\n        \u0026self,\n        cx: \u0026Cx,\n        sql: \u0026str,\n        params: \u0026[Value],\n    ) -\u003e Outcome\u003cimpl Stream\u003cItem = Outcome\u003cRow, Error\u003e\u003e, Error\u003e;\n    \n    /// Execute a statement (INSERT, UPDATE, DELETE) and return rows affected.\n    async fn execute(\n        \u0026self,\n        cx: \u0026Cx,\n        sql: \u0026str,\n        params: \u0026[Value],\n    ) -\u003e Outcome\u003cu64, Error\u003e;\n    \n    /// Execute INSERT and return the last inserted row ID.\n    async fn insert(\n        \u0026self,\n        cx: \u0026Cx,\n        sql: \u0026str,\n        params: \u0026[Value],\n    ) -\u003e Outcome\u003ci64, Error\u003e;\n    \n    /// Execute multiple statements in a batch.\n    async fn batch(\n        \u0026self,\n        cx: \u0026Cx,\n        statements: \u0026[(String, Vec\u003cValue\u003e)],\n    ) -\u003e Outcome\u003cVec\u003cu64\u003e, Error\u003e;\n    \n    /// Begin a transaction.\n    async fn begin(\u0026self, cx: \u0026Cx) -\u003e Outcome\u003cSelf::Transaction\u003c'_\u003e, Error\u003e;\n    \n    /// Begin a transaction with specific isolation level.\n    async fn begin_with(\n        \u0026self,\n        cx: \u0026Cx,\n        isolation: IsolationLevel,\n    ) -\u003e Outcome\u003cSelf::Transaction\u003c'_\u003e, Error\u003e;\n    \n    /// Prepare a statement for repeated execution.\n    async fn prepare(\n        \u0026self,\n        cx: \u0026Cx,\n        sql: \u0026str,\n    ) -\u003e Outcome\u003cPreparedStatement, Error\u003e;\n    \n    /// Check if connection is still valid.\n    async fn ping(\u0026self, cx: \u0026Cx) -\u003e Outcome\u003c(), Error\u003e;\n    \n    /// Close the connection gracefully.\n    async fn close(self, cx: \u0026Cx) -\u003e Outcome\u003c(), Error\u003e;\n}\n```\n\n### Transaction Trait\n```rust\n/// An active database transaction.\n/// \n/// Transactions must be explicitly committed or rolled back.\n/// Dropping without commit will automatically rollback.\npub trait Transaction\u003c'conn\u003e: Send {\n    /// Execute a query within the transaction.\n    async fn query(\n        \u0026self,\n        cx: \u0026Cx,\n        sql: \u0026str,\n        params: \u0026[Value],\n    ) -\u003e Outcome\u003cVec\u003cRow\u003e, Error\u003e;\n    \n    /// Execute within the transaction.\n    async fn execute(\n        \u0026self,\n        cx: \u0026Cx,\n        sql: \u0026str,\n        params: \u0026[Value],\n    ) -\u003e Outcome\u003cu64, Error\u003e;\n    \n    /// Create a savepoint.\n    async fn savepoint(\u0026self, cx: \u0026Cx, name: \u0026str) -\u003e Outcome\u003c(), Error\u003e;\n    \n    /// Rollback to a savepoint.\n    async fn rollback_to(\u0026self, cx: \u0026Cx, name: \u0026str) -\u003e Outcome\u003c(), Error\u003e;\n    \n    /// Release a savepoint.\n    async fn release(\u0026self, cx: \u0026Cx, name: \u0026str) -\u003e Outcome\u003c(), Error\u003e;\n    \n    /// Commit the transaction.\n    async fn commit(self, cx: \u0026Cx) -\u003e Outcome\u003c(), Error\u003e;\n    \n    /// Rollback the transaction.\n    async fn rollback(self, cx: \u0026Cx) -\u003e Outcome\u003c(), Error\u003e;\n}\n```\n\n### Isolation Levels\n```rust\n#[derive(Debug, Clone, Copy, Default)]\npub enum IsolationLevel {\n    #[default]\n    ReadCommitted,\n    RepeatableRead,\n    Serializable,\n    ReadUncommitted,  // Use with caution\n}\n```\n\n### Prepared Statement\n```rust\npub struct PreparedStatement {\n    id: u64,\n    sql: String,\n    param_count: usize,\n}\n\nimpl PreparedStatement {\n    pub async fn execute(\n        \u0026self,\n        cx: \u0026Cx,\n        conn: \u0026impl Connection,\n        params: \u0026[Value],\n    ) -\u003e Outcome\u003cu64, Error\u003e;\n    \n    pub async fn query(\n        \u0026self,\n        cx: \u0026Cx,\n        conn: \u0026impl Connection,\n        params: \u0026[Value],\n    ) -\u003e Outcome\u003cVec\u003cRow\u003e, Error\u003e;\n}\n```\n\n## Testing Requirements\n- Mock connection for trait testing\n- Transaction rollback on drop\n- Isolation level propagation\n- Prepared statement parameter validation\n- Cancellation handling in all methods\n\n## Acceptance Criteria\n- [ ] Connection trait fully defined with all methods\n- [ ] Transaction trait with savepoint support\n- [ ] IsolationLevel enum\n- [ ] PreparedStatement type\n- [ ] Documentation for all methods\n- [ ] Mock implementation for testing\n\n## Files to Modify\n- crates/sqlmodel-core/src/connection.rs\n- crates/sqlmodel-core/src/transaction.rs (new)\n- crates/sqlmodel-core/src/prepared.rs (new)\n\n## Estimated Effort\n~250 lines of trait definitions","status":"in_progress","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:20:37.407765254-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T12:41:03.118199695-05:00","dependencies":[{"issue_id":"sqlmodel_rust-53e.3","depends_on_id":"sqlmodel_rust-53e","type":"parent-child","created_at":"2026-01-17T11:20:37.408960616-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-53e.4","title":"Core: Implement comprehensive Error types","description":"# Task: Implement Comprehensive Error Types\n\n## Context\nGood error handling is critical for a database library. Users need to know exactly what went wrong, where, and ideally how to fix it. Errors should support both programmatic handling (matching on variants) and human-readable messages.\n\n## Current State\nBasic Error enum exists with: Connection, Query, TypeConversion, Serde, Custom.\n\n## Required Design\n\n### Error Hierarchy\n```rust\n/// Main error type for SQLModel operations.\n#[derive(Debug)]\npub enum Error {\n    // Connection errors\n    Connection(ConnectionError),\n    \n    // Query execution errors\n    Query(QueryError),\n    \n    // Type conversion errors\n    Type(TypeError),\n    \n    // Transaction errors\n    Transaction(TransactionError),\n    \n    // Protocol errors (for wire protocols)\n    Protocol(ProtocolError),\n    \n    // Pool errors\n    Pool(PoolError),\n    \n    // Schema/migration errors\n    Schema(SchemaError),\n    \n    // Configuration errors\n    Config(ConfigError),\n    \n    // IO errors\n    Io(std::io::Error),\n    \n    // Timeout\n    Timeout,\n    \n    // Cancelled via Cx\n    Cancelled,\n}\n\n#[derive(Debug)]\npub struct ConnectionError {\n    pub kind: ConnectionErrorKind,\n    pub message: String,\n    pub source: Option\u003cBox\u003cdyn std::error::Error + Send + Sync\u003e\u003e,\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum ConnectionErrorKind {\n    /// Failed to establish connection\n    Connect,\n    /// Authentication failed\n    Authentication,\n    /// Connection lost during operation\n    Disconnected,\n    /// SSL/TLS negotiation failed\n    Ssl,\n    /// DNS resolution failed\n    DnsResolution,\n    /// Connection refused\n    Refused,\n    /// Connection pool exhausted\n    PoolExhausted,\n}\n\n#[derive(Debug)]\npub struct QueryError {\n    pub kind: QueryErrorKind,\n    pub sql: Option\u003cString\u003e,\n    pub sqlstate: Option\u003cString\u003e,\n    pub message: String,\n    pub detail: Option\u003cString\u003e,\n    pub hint: Option\u003cString\u003e,\n    pub position: Option\u003cusize\u003e,\n    pub source: Option\u003cBox\u003cdyn std::error::Error + Send + Sync\u003e\u003e,\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum QueryErrorKind {\n    /// Syntax error in SQL\n    Syntax,\n    /// Constraint violation (unique, foreign key, etc.)\n    Constraint,\n    /// Table/column not found\n    NotFound,\n    /// Permission denied\n    Permission,\n    /// Data too large for column\n    DataTruncation,\n    /// Deadlock detected\n    Deadlock,\n    /// Serialization failure (retry may succeed)\n    Serialization,\n    /// Statement timeout\n    Timeout,\n    /// Cancelled\n    Cancelled,\n    /// Other database error\n    Database,\n}\n\n#[derive(Debug)]\npub struct TypeError {\n    pub expected: \u0026'static str,\n    pub actual: String,\n    pub column: Option\u003cString\u003e,\n    pub rust_type: Option\u003c\u0026'static str\u003e,\n}\n\n#[derive(Debug)]\npub struct TransactionError {\n    pub kind: TransactionErrorKind,\n    pub message: String,\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum TransactionErrorKind {\n    /// Already committed\n    AlreadyCommitted,\n    /// Already rolled back\n    AlreadyRolledBack,\n    /// Savepoint not found\n    SavepointNotFound,\n    /// Nested transaction not supported\n    NestedNotSupported,\n}\n\n#[derive(Debug)]\npub struct ProtocolError {\n    pub message: String,\n    pub raw_data: Option\u003cVec\u003cu8\u003e\u003e,\n}\n```\n\n### Error Traits\n```rust\nimpl std::error::Error for Error {\n    fn source(\u0026self) -\u003e Option\u003c\u0026(dyn std::error::Error + 'static)\u003e;\n}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result;\n}\n\n// Conversions\nimpl From\u003cstd::io::Error\u003e for Error;\nimpl From\u003cConnectionError\u003e for Error;\nimpl From\u003cQueryError\u003e for Error;\n// etc.\n```\n\n### Helper Methods\n```rust\nimpl Error {\n    /// Is this a retryable error (deadlock, serialization, pool exhausted)?\n    pub fn is_retryable(\u0026self) -\u003e bool;\n    \n    /// Is this a connection error that requires reconnection?\n    pub fn is_connection_error(\u0026self) -\u003e bool;\n    \n    /// Get SQLSTATE if available (e.g., \"23505\" for unique violation)\n    pub fn sqlstate(\u0026self) -\u003e Option\u003c\u0026str\u003e;\n    \n    /// Get the SQL that caused this error, if available\n    pub fn sql(\u0026self) -\u003e Option\u003c\u0026str\u003e;\n}\n\nimpl QueryError {\n    /// Is this a unique constraint violation?\n    pub fn is_unique_violation(\u0026self) -\u003e bool {\n        self.sqlstate.as_deref() == Some(\"23505\")\n    }\n    \n    /// Is this a foreign key violation?\n    pub fn is_foreign_key_violation(\u0026self) -\u003e bool {\n        self.sqlstate.as_deref() == Some(\"23503\")\n    }\n}\n```\n\n### Result Type Alias\n```rust\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n```\n\n## Testing Requirements\n- Display formatting for all variants\n- Error chaining (source)\n- SQLSTATE matching\n- is_retryable for known retryable errors\n- Conversion from io::Error\n\n## Acceptance Criteria\n- [ ] All error types defined with rich context\n- [ ] std::error::Error implemented\n- [ ] Display implemented with helpful messages\n- [ ] SQLSTATE support for database errors\n- [ ] Retryable error identification\n- [ ] Connection error classification\n- [ ] Type errors include column context\n\n## Files to Modify\n- crates/sqlmodel-core/src/error.rs\n\n## Estimated Effort\n~400 lines of error definitions","status":"open","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:21:01.157687256-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:21:01.157687256-05:00","dependencies":[{"issue_id":"sqlmodel_rust-53e.4","depends_on_id":"sqlmodel_rust-53e","type":"parent-child","created_at":"2026-01-17T11:21:01.158970653-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-53e.5","title":"Core: Define Model trait and FieldInfo","description":"# Task: Define Model Trait and FieldInfo\n\n## Context\nThe Model trait is the core abstraction that connects Rust structs to database tables. It provides metadata about the table, columns, and type mappings. The derive macro will implement this trait.\n\n## Current State\nBasic Model trait exists. Needs enhancement for full functionality.\n\n## Required Design\n\n### Model Trait\n```rust\n/// Trait for types that can be persisted to a database.\n/// \n/// This trait is typically derived using `#[derive(Model)]`.\n/// It provides all metadata needed for CRUD operations.\npub trait Model: Sized + Send + Sync {\n    /// Table name in the database\n    const TABLE_NAME: \u0026'static str;\n    \n    /// Primary key column name(s)\n    /// For composite keys, comma-separated\n    const PRIMARY_KEY: \u0026'static [\u0026'static str];\n    \n    /// Whether the primary key is auto-generated\n    const AUTO_INCREMENT: bool;\n    \n    /// Get field metadata for all columns\n    fn fields() -\u003e \u0026'static [FieldInfo];\n    \n    /// Get field info by name\n    fn field(name: \u0026str) -\u003e Option\u003c\u0026'static FieldInfo\u003e {\n        Self::fields().iter().find(|f| f.name == name)\n    }\n    \n    /// Convert from a database row\n    fn from_row(row: \u0026Row) -\u003e Result\u003cSelf\u003e;\n    \n    /// Convert to values for INSERT (excludes auto-increment fields)\n    fn to_insert_values(\u0026self) -\u003e Vec\u003cValue\u003e;\n    \n    /// Convert to values for UPDATE (all fields)\n    fn to_update_values(\u0026self) -\u003e Vec\u003cValue\u003e;\n    \n    /// Get primary key value(s) from instance\n    fn primary_key_values(\u0026self) -\u003e Vec\u003cValue\u003e;\n    \n    /// Column names for INSERT (excludes auto-increment)\n    fn insert_columns() -\u003e \u0026'static [\u0026'static str];\n    \n    /// Column names for UPDATE\n    fn update_columns() -\u003e \u0026'static [\u0026'static str];\n    \n    /// All column names\n    fn columns() -\u003e \u0026'static [\u0026'static str];\n}\n```\n\n### FieldInfo Structure\n```rust\n/// Metadata about a model field/column.\n#[derive(Debug, Clone)]\npub struct FieldInfo {\n    /// Rust field name\n    pub name: \u0026'static str,\n    \n    /// Database column name (may differ from field name)\n    pub column_name: \u0026'static str,\n    \n    /// SQL type for this field\n    pub sql_type: SqlType,\n    \n    /// Whether this field is nullable (Option\u003cT\u003e)\n    pub nullable: bool,\n    \n    /// Whether this is part of the primary key\n    pub primary_key: bool,\n    \n    /// Whether this field auto-increments\n    pub auto_increment: bool,\n    \n    /// Whether this field must be unique\n    pub unique: bool,\n    \n    /// Foreign key reference (\"table.column\")\n    pub foreign_key: Option\u003c\u0026'static str\u003e,\n    \n    /// Default value expression\n    pub default: Option\u003c\u0026'static str\u003e,\n    \n    /// Whether to include in SELECT\n    pub selectable: bool,\n    \n    /// Whether to include in INSERT\n    pub insertable: bool,\n    \n    /// Whether to include in UPDATE\n    pub updatable: bool,\n    \n    /// Index of this field in the struct\n    pub index: usize,\n}\n```\n\n### SqlType Enum\n```rust\n/// SQL column types.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum SqlType {\n    // Integers\n    TinyInt,\n    SmallInt,\n    Integer,\n    BigInt,\n    \n    // Floating point\n    Real,\n    Double,\n    Numeric { precision: u8, scale: u8 },\n    \n    // Strings\n    Char(u32),\n    VarChar(u32),\n    Text,\n    \n    // Binary\n    Binary(u32),\n    VarBinary(u32),\n    Blob,\n    \n    // Date/Time\n    Date,\n    Time,\n    DateTime,\n    Timestamp,\n    TimestampTz,\n    \n    // Boolean\n    Boolean,\n    \n    // JSON\n    Json,\n    JsonB,\n    \n    // UUID\n    Uuid,\n    \n    // Arrays (PostgreSQL)\n    Array(Box\u003cSqlType\u003e),\n    \n    // Custom type name\n    Custom(\u0026'static str),\n}\n\nimpl SqlType {\n    /// Get the SQL type name for a specific dialect\n    pub fn sql_name(\u0026self, dialect: Dialect) -\u003e \u0026'static str;\n    \n    /// Default Rust type that maps to this SQL type\n    pub fn default_rust_type(\u0026self) -\u003e \u0026'static str;\n}\n```\n\n### Type Mapping\n```rust\n/// Map Rust types to SQL types\npub trait ToSqlType {\n    fn sql_type() -\u003e SqlType;\n}\n\nimpl ToSqlType for i32 { fn sql_type() -\u003e SqlType { SqlType::Integer } }\nimpl ToSqlType for i64 { fn sql_type() -\u003e SqlType { SqlType::BigInt } }\nimpl ToSqlType for String { fn sql_type() -\u003e SqlType { SqlType::Text } }\nimpl ToSqlType for bool { fn sql_type() -\u003e SqlType { SqlType::Boolean } }\nimpl\u003cT: ToSqlType\u003e ToSqlType for Option\u003cT\u003e { fn sql_type() -\u003e SqlType { T::sql_type() } }\n// etc.\n```\n\n## Testing Requirements\n- Model trait can be implemented manually\n- FieldInfo correctly represents all field attributes\n- SqlType generates correct SQL for each dialect\n- ToSqlType maps all common Rust types\n\n## Acceptance Criteria\n- [ ] Model trait fully defined\n- [ ] FieldInfo captures all metadata needed\n- [ ] SqlType covers all common SQL types\n- [ ] Dialect-aware SQL type names\n- [ ] ToSqlType implemented for primitives\n- [ ] Documentation with examples\n\n## Files to Modify\n- crates/sqlmodel-core/src/model.rs\n- crates/sqlmodel-core/src/field.rs\n- crates/sqlmodel-core/src/types.rs\n\n## Estimated Effort\n~350 lines of trait/struct definitions","status":"open","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:21:24.889721049-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:21:24.889721049-05:00","dependencies":[{"issue_id":"sqlmodel_rust-53e.5","depends_on_id":"sqlmodel_rust-53e","type":"parent-child","created_at":"2026-01-17T11:21:24.891156703-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-53e.6","title":"Core: Unit tests for all core types","description":"# Task: Unit Tests for All Core Types\n\n## Context\nComprehensive unit tests for sqlmodel-core to ensure Value, Row, Error, and Model types work correctly in all cases.\n\n## Test Categories\n\n### Value Tests\n- Round-trip conversion: T -\u003e Value -\u003e T for all types\n- Null handling: Value::Null conversions\n- Type coercion: Valid conversions (i32 -\u003e i64)\n- Type errors: Invalid conversions return proper errors\n- Edge cases: i64::MAX, f64::INFINITY, empty strings\n- Display formatting for debugging\n- Equality and ordering\n\n### Row Tests\n- Index access: valid and invalid indices\n- Named access: valid and invalid names\n- Type conversion: get_as\u003cT\u003e for all types\n- Column iteration: names and values\n- Arc sharing: verify ColumnInfo is shared\n- Empty rows\n- Wide rows (100+ columns)\n\n### Error Tests\n- Display formatting for all variants\n- Error chaining (source)\n- SQLSTATE classification\n- is_retryable() correctness\n- From conversions\n\n### Model Tests\n- Manual Model impl for test struct\n- FieldInfo correctness\n- SqlType SQL names by dialect\n- ToSqlType for all primitives\n\n## Test Infrastructure\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    // Test fixtures\n    fn sample_values() -\u003e Vec\u003cValue\u003e { ... }\n    fn sample_row() -\u003e Row { ... }\n    \n    // Property-based tests with proptest\n    proptest! {\n        #[test]\n        fn value_roundtrip_i64(v: i64) {\n            let value = Value::BigInt(v);\n            let back: i64 = value.try_into().unwrap();\n            assert_eq!(v, back);\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] \u003e95% code coverage for value.rs\n- [ ] \u003e95% code coverage for row.rs\n- [ ] \u003e95% code coverage for error.rs\n- [ ] \u003e95% code coverage for model.rs\n- [ ] Property tests for round-trip conversions\n- [ ] Edge case tests documented\n\n## Files to Create/Modify\n- crates/sqlmodel-core/src/value.rs (add tests module)\n- crates/sqlmodel-core/src/row.rs (add tests module)\n- crates/sqlmodel-core/src/error.rs (add tests module)\n- crates/sqlmodel-core/src/model.rs (add tests module)\n\n## Estimated Effort\n~500 lines of test code","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:21:39.522046719-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:21:39.522046719-05:00","dependencies":[{"issue_id":"sqlmodel_rust-53e.6","depends_on_id":"sqlmodel_rust-53e","type":"parent-child","created_at":"2026-01-17T11:21:39.523273099-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-6bs","title":"SQLModel Rust: SQLite Driver","description":"# Epic: SQLite Driver (sqlmodel-sqlite)\n\n## Overview\nThis epic implements the SQLite database driver using FFI bindings to libsqlite3. SQLite is an embedded database (no network protocol), so we wrap the C library with safe Rust abstractions and integrate with asupersync.\n\n## Rationale\nSQLite is fundamentally different from PostgreSQL/MySQL:\n- File-based, not client-server\n- No network protocol to implement\n- Uses C library via FFI\n- Single-writer, multiple-reader model\n\nWe use FFI because:\n- SQLite file format is complex (B-trees, pages, WAL)\n- Implementing from scratch would be a database engine\n- libsqlite3 is battle-tested and optimized\n- FFI is the standard approach (rusqlite does this too)\n\n## Key Components\n\n### 1. FFI Bindings (ffi.rs)\nLow-level bindings to libsqlite3:\n- sqlite3_open_v2, sqlite3_close\n- sqlite3_prepare_v2, sqlite3_finalize\n- sqlite3_step, sqlite3_reset\n- sqlite3_bind_* (parameter binding)\n- sqlite3_column_* (result fetching)\n- sqlite3_exec, sqlite3_changes\n- sqlite3_errmsg, sqlite3_errcode\n\n### 2. Safe Wrapper Types\n- SqliteConnection: Owns sqlite3* handle\n- SqliteStatement: Owns sqlite3_stmt* handle\n- SqliteRow: Represents a result row\n- SqliteTransaction: Manages BEGIN/COMMIT/ROLLBACK\n\n### 3. Type Mapping\nRust to SQLite:\n- i32, i64 -\u003e INTEGER\n- f32, f64 -\u003e REAL\n- String, \u0026str -\u003e TEXT\n- Vec\u003cu8\u003e, \u0026[u8] -\u003e BLOB\n- bool -\u003e INTEGER (0/1)\n- Option\u003cT\u003e -\u003e NULL or T\n\nSQLite to Rust:\n- INTEGER -\u003e i64 (then convert)\n- REAL -\u003e f64\n- TEXT -\u003e String\n- BLOB -\u003e Vec\u003cu8\u003e\n- NULL -\u003e Option::None\n\n### 4. Connection Implementation\nImplement Connection trait for SqliteConnection:\n- query() -\u003e Outcome\u003cVec\u003cRow\u003e, Error\u003e\n- query_one() -\u003e Outcome\u003cOption\u003cRow\u003e, Error\u003e\n- execute() -\u003e Outcome\u003cu64, Error\u003e\n- insert() -\u003e Outcome\u003ci64, Error\u003e (last_insert_rowid)\n- begin() -\u003e Outcome\u003cTransaction, Error\u003e\n\n### 5. asupersync Integration\n- Wrap blocking FFI calls in spawn_blocking equivalent\n- Support cancellation via periodic checks\n- Budget/timeout support\n\n## SQLite-Specific Features\n- PRAGMA support for configuration\n- WAL mode for concurrent reads\n- Busy timeout for lock contention\n- User-defined functions (future)\n- Virtual tables (future)\n\n## Key Design Decisions\n1. **Use libsqlite3-sys or manual FFI**: Start with manual for control\n2. **Statement caching**: Cache prepared statements for performance\n3. **Connection modes**: Support read-only, read-write, create\n4. **Thread safety**: SQLite has its own threading model; respect it\n5. **Memory management**: Proper cleanup of C resources\n\n## Success Criteria\n- [ ] Open/close connections to SQLite files\n- [ ] Execute queries with parameter binding\n- [ ] Fetch results as Value/Row types\n- [ ] Transaction support (begin/commit/rollback)\n- [ ] Correct NULL handling\n- [ ] All type conversions work correctly\n- [ ] Error messages include SQLite error details\n- [ ] No memory leaks (valgrind clean)\n- [ ] Works with in-memory databases (:memory:)\n- [ ] Concurrent read access works correctly\n\n## Dependencies\n- sqlmodel-core (Connection trait, Value, Row, Error)\n- libsqlite3 (system library)\n- asupersync (for async integration)\n\n## Estimated Scope\n~800 lines of FFI wrapper code","status":"open","priority":1,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:18:17.497953413-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:18:17.497953413-05:00"}
{"id":"sqlmodel_rust-6vd","title":"SQLModel Rust: Query Builder Layer","description":"# Epic: Query Builder Layer (sqlmodel-query)\n\n## Overview\nThis epic implements the type-safe SQL query builder that generates SELECT, INSERT, UPDATE, and DELETE statements. It provides a fluent API similar to SQLAlchemy's expression language but with compile-time type safety.\n\n## Rationale\nPython SQLModel/SQLAlchemy builds queries at runtime using method chaining. We preserve this ergonomic API while adding:\n- Compile-time validation of column references\n- Type-safe expression building\n- Parameterized queries (SQL injection prevention)\n- Dialect-aware SQL generation\n\n## Key Components\n\n### 1. Expression System (expr.rs)\nThe foundation for building WHERE clauses and computed values:\n- Column references: Expr::col(\"name\")\n- Literals: Expr::lit(42), Expr::lit(\"hello\")\n- Binary ops: eq, ne, lt, gt, le, ge, like, in_list\n- Logical ops: and, or, not\n- Null checks: is_null, is_not_null\n- Functions: count, sum, avg, min, max\n\n### 2. SELECT Builder (select.rs)\nFluent interface for SELECT queries:\n- select!(Model) macro entry point\n- .filter(expr) for WHERE clauses\n- .order_by(col.asc()/desc())\n- .limit(n), .offset(n)\n- .join(Model, on_expr) for JOINs\n- .all(cx, conn) -\u003e Vec\u003cModel\u003e\n- .first(cx, conn) -\u003e Option\u003cModel\u003e\n- .count(cx, conn) -\u003e u64\n\n### 3. INSERT Builder (builder.rs)\n- insert!(model) macro entry point\n- Single row insert\n- Bulk insert with .values(vec![...])\n- .returning(cols) for PostgreSQL\n- .execute(cx, conn) -\u003e last_insert_id\n\n### 4. UPDATE Builder (builder.rs)\n- update!(model) for updating existing model\n- .set(col, value) for partial updates\n- .filter(expr) for conditional update\n- .execute(cx, conn) -\u003e rows_affected\n\n### 5. DELETE Builder (builder.rs)\n- delete!(Model) macro entry point\n- .filter(expr) for conditional delete\n- .execute(cx, conn) -\u003e rows_affected\n\n## Key Design Decisions\n1. **Macro entry points**: select!/insert!/update!/delete! provide ergonomic API\n2. **Builder pattern**: Each method returns Self for chaining\n3. **Deferred execution**: Query only runs when .all()/.execute() called\n4. **Parameterized queries**: Values passed separately, never interpolated\n5. **Dialect abstraction**: SQL generation is dialect-aware (SQLite vs PostgreSQL vs MySQL)\n\n## Success Criteria\n- [ ] All CRUD operations supported\n- [ ] Complex WHERE expressions with AND/OR/NOT\n- [ ] JOIN support (INNER, LEFT, RIGHT, FULL)\n- [ ] ORDER BY with multiple columns\n- [ ] LIMIT/OFFSET pagination\n- [ ] Aggregate functions\n- [ ] Subqueries (basic support)\n- [ ] SQL injection impossible by design\n- [ ] Generated SQL is readable and efficient\n\n## Dependencies\n- sqlmodel-core (Value, Row, Connection traits)\n\n## Estimated Scope\n~1200 lines of query builder code","status":"open","priority":0,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:17:23.82221618-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:17:23.82221618-05:00"}
{"id":"sqlmodel_rust-6vd.1","title":"Query: Implement expression system","description":"# Task: Implement Expression System\n\n## Context\nThe expression system is the foundation for building WHERE clauses, ORDER BY, and computed columns. It must be type-safe and generate correct SQL for each dialect.\n\n## Expression Types\n\n### Core Expression Enum\n```rust\n#[derive(Debug, Clone)]\npub enum Expr {\n    /// Column reference: \"users\".\"name\"\n    Column {\n        table: Option\u003cString\u003e,\n        name: String,\n    },\n    \n    /// Literal value: 42, 'hello', NULL\n    Literal(Value),\n    \n    /// Binary operation: a = b, a \u003e b, a AND b\n    Binary {\n        left: Box\u003cExpr\u003e,\n        op: BinaryOp,\n        right: Box\u003cExpr\u003e,\n    },\n    \n    /// Unary operation: NOT a, -a, a IS NULL\n    Unary {\n        op: UnaryOp,\n        expr: Box\u003cExpr\u003e,\n    },\n    \n    /// Function call: COUNT(*), UPPER(name)\n    Function {\n        name: String,\n        args: Vec\u003cExpr\u003e,\n    },\n    \n    /// CASE WHEN ... THEN ... ELSE ... END\n    Case {\n        when_clauses: Vec\u003c(Expr, Expr)\u003e,\n        else_clause: Option\u003cBox\u003cExpr\u003e\u003e,\n    },\n    \n    /// Subquery: (SELECT ...)\n    Subquery(Box\u003cSelect\u003c()\u003e\u003e),\n    \n    /// IN list: a IN (1, 2, 3)\n    InList {\n        expr: Box\u003cExpr\u003e,\n        list: Vec\u003cExpr\u003e,\n        negated: bool,\n    },\n    \n    /// BETWEEN: a BETWEEN 1 AND 10\n    Between {\n        expr: Box\u003cExpr\u003e,\n        low: Box\u003cExpr\u003e,\n        high: Box\u003cExpr\u003e,\n        negated: bool,\n    },\n    \n    /// LIKE: name LIKE '%foo%'\n    Like {\n        expr: Box\u003cExpr\u003e,\n        pattern: String,\n        negated: bool,\n    },\n    \n    /// Placeholder for bound parameters: $1, ?\n    Placeholder(usize),\n    \n    /// Raw SQL expression (escape hatch)\n    Raw(String),\n}\n```\n\n### Binary Operations\n```rust\n#[derive(Debug, Clone, Copy)]\npub enum BinaryOp {\n    // Comparison\n    Eq,      // =\n    Ne,      // != or \u003c\u003e\n    Lt,      // \u003c\n    Le,      // \u003c=\n    Gt,      // \u003e\n    Ge,      // \u003e=\n    \n    // Logical\n    And,     // AND\n    Or,      // OR\n    \n    // Arithmetic\n    Add,     // +\n    Sub,     // -\n    Mul,     // *\n    Div,     // /\n    Mod,     // %\n    \n    // String\n    Concat,  // || (PostgreSQL) or CONCAT() (MySQL)\n    \n    // Bitwise\n    BitAnd,  // \u0026\n    BitOr,   // |\n    BitXor,  // ^\n}\n```\n\n### Unary Operations\n```rust\n#[derive(Debug, Clone, Copy)]\npub enum UnaryOp {\n    Not,         // NOT\n    Negate,      // -\n    IsNull,      // IS NULL\n    IsNotNull,   // IS NOT NULL\n    BitNot,      // ~\n}\n```\n\n### Fluent Builder Methods\n```rust\nimpl Expr {\n    // Constructors\n    pub fn col(name: \u0026str) -\u003e Self;\n    pub fn qualified(table: \u0026str, column: \u0026str) -\u003e Self;\n    pub fn lit\u003cT: Into\u003cValue\u003e\u003e(value: T) -\u003e Self;\n    pub fn null() -\u003e Self;\n    \n    // Comparison (return Expr for chaining)\n    pub fn eq\u003cT: Into\u003cExpr\u003e\u003e(self, other: T) -\u003e Self;\n    pub fn ne\u003cT: Into\u003cExpr\u003e\u003e(self, other: T) -\u003e Self;\n    pub fn lt\u003cT: Into\u003cExpr\u003e\u003e(self, other: T) -\u003e Self;\n    pub fn le\u003cT: Into\u003cExpr\u003e\u003e(self, other: T) -\u003e Self;\n    pub fn gt\u003cT: Into\u003cExpr\u003e\u003e(self, other: T) -\u003e Self;\n    pub fn ge\u003cT: Into\u003cExpr\u003e\u003e(self, other: T) -\u003e Self;\n    \n    // Logical\n    pub fn and\u003cT: Into\u003cExpr\u003e\u003e(self, other: T) -\u003e Self;\n    pub fn or\u003cT: Into\u003cExpr\u003e\u003e(self, other: T) -\u003e Self;\n    pub fn not(self) -\u003e Self;\n    \n    // Null checks\n    pub fn is_null(self) -\u003e Self;\n    pub fn is_not_null(self) -\u003e Self;\n    \n    // Containment\n    pub fn in_list\u003cT: Into\u003cExpr\u003e\u003e(self, list: Vec\u003cT\u003e) -\u003e Self;\n    pub fn not_in\u003cT: Into\u003cExpr\u003e\u003e(self, list: Vec\u003cT\u003e) -\u003e Self;\n    pub fn between\u003cT: Into\u003cExpr\u003e\u003e(self, low: T, high: T) -\u003e Self;\n    pub fn not_between\u003cT: Into\u003cExpr\u003e\u003e(self, low: T, high: T) -\u003e Self;\n    \n    // Pattern matching\n    pub fn like(self, pattern: \u0026str) -\u003e Self;\n    pub fn not_like(self, pattern: \u0026str) -\u003e Self;\n    pub fn ilike(self, pattern: \u0026str) -\u003e Self; // Case-insensitive (PG)\n    \n    // Ordering (for ORDER BY)\n    pub fn asc(self) -\u003e OrderBy;\n    pub fn desc(self) -\u003e OrderBy;\n    pub fn nulls_first(self) -\u003e OrderBy;\n    pub fn nulls_last(self) -\u003e OrderBy;\n}\n\n// Aggregate functions\nimpl Expr {\n    pub fn count() -\u003e Self;          // COUNT(*)\n    pub fn count_expr(self) -\u003e Self; // COUNT(expr)\n    pub fn sum(self) -\u003e Self;\n    pub fn avg(self) -\u003e Self;\n    pub fn min(self) -\u003e Self;\n    pub fn max(self) -\u003e Self;\n}\n```\n\n### SQL Generation\n```rust\nimpl Expr {\n    pub fn to_sql(\u0026self, dialect: Dialect, params: \u0026mut Vec\u003cValue\u003e) -\u003e String {\n        match self {\n            Expr::Column { table, name } =\u003e {\n                if let Some(t) = table {\n                    format!(\"\\\"{}\\\".\\\"{}\\\"\", t, name)\n                } else {\n                    format!(\"\\\"{}\\\"\", name)\n                }\n            }\n            Expr::Literal(value) =\u003e {\n                params.push(value.clone());\n                dialect.placeholder(params.len())\n            }\n            Expr::Binary { left, op, right } =\u003e {\n                let l = left.to_sql(dialect, params);\n                let r = right.to_sql(dialect, params);\n                format!(\"({} {} {})\", l, op.to_sql(), r)\n            }\n            // ... other cases\n        }\n    }\n}\n```\n\n## Testing Requirements\n- All operator combinations\n- Nested expressions\n- SQL generation for each dialect\n- Parameter collection\n- Edge cases (NULL, empty lists)\n\n## Acceptance Criteria\n- [ ] All expression types implemented\n- [ ] Fluent builder API\n- [ ] Correct SQL generation\n- [ ] Proper parameter binding\n- [ ] Dialect-specific output\n- [ ] Comprehensive tests\n\n## Files to Modify\n- crates/sqlmodel-query/src/expr.rs\n\n## Estimated Effort\n~400 lines of expression code","status":"open","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:23:54.841872902-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:23:54.841872902-05:00","dependencies":[{"issue_id":"sqlmodel_rust-6vd.1","depends_on_id":"sqlmodel_rust-6vd","type":"parent-child","created_at":"2026-01-17T11:23:54.843269011-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-6vd.2","title":"Query: Implement SELECT builder with execution","description":"# Task: Implement SELECT Builder with Execution\n\n## Context\nThe SELECT builder is the primary way to query data. It supports WHERE, ORDER BY, LIMIT, OFFSET, JOINs, and aggregations, all with a fluent API.\n\n## API Design\n\n### Basic Usage\n```rust\n// Type-safe SELECT returning Vec\u003cHero\u003e\nlet heroes: Vec\u003cHero\u003e = select!(Hero)\n    .filter(Expr::col(\"age\").gt(18))\n    .order_by(Expr::col(\"name\").asc())\n    .limit(10)\n    .all(cx, \u0026conn)\n    .await?;\n\n// Single result\nlet hero: Option\u003cHero\u003e = select!(Hero)\n    .filter(Expr::col(\"id\").eq(42))\n    .first(cx, \u0026conn)\n    .await?;\n\n// Count\nlet count: u64 = select!(Hero)\n    .filter(Expr::col(\"team_id\").is_not_null())\n    .count(cx, \u0026conn)\n    .await?;\n```\n\n### Select Struct\n```rust\npub struct Select\u003cM: Model\u003e {\n    /// Columns to select (None = all columns)\n    columns: Option\u003cVec\u003cExpr\u003e\u003e,\n    /// Table name (from Model)\n    table: String,\n    /// Table alias\n    alias: Option\u003cString\u003e,\n    /// WHERE clause\n    filter: Option\u003cExpr\u003e,\n    /// ORDER BY clauses\n    order_by: Vec\u003cOrderBy\u003e,\n    /// LIMIT\n    limit: Option\u003cu64\u003e,\n    /// OFFSET\n    offset: Option\u003cu64\u003e,\n    /// JOIN clauses\n    joins: Vec\u003cJoin\u003e,\n    /// GROUP BY columns\n    group_by: Vec\u003cExpr\u003e,\n    /// HAVING clause\n    having: Option\u003cExpr\u003e,\n    /// DISTINCT\n    distinct: bool,\n    /// FOR UPDATE (locking)\n    for_update: bool,\n    /// Phantom for Model type\n    _marker: PhantomData\u003cM\u003e,\n}\n```\n\n### Builder Methods\n```rust\nimpl\u003cM: Model\u003e Select\u003cM\u003e {\n    pub fn new() -\u003e Self;\n    \n    // Filtering\n    pub fn filter(mut self, expr: Expr) -\u003e Self {\n        self.filter = Some(match self.filter {\n            Some(existing) =\u003e existing.and(expr),\n            None =\u003e expr,\n        });\n        self\n    }\n    \n    // Ordering\n    pub fn order_by(mut self, order: OrderBy) -\u003e Self {\n        self.order_by.push(order);\n        self\n    }\n    \n    // Pagination\n    pub fn limit(mut self, n: u64) -\u003e Self {\n        self.limit = Some(n);\n        self\n    }\n    \n    pub fn offset(mut self, n: u64) -\u003e Self {\n        self.offset = Some(n);\n        self\n    }\n    \n    // JOINs\n    pub fn join\u003cJ: Model\u003e(mut self, on: Expr) -\u003e Self {\n        self.joins.push(Join::inner::\u003cJ\u003e(on));\n        self\n    }\n    \n    pub fn left_join\u003cJ: Model\u003e(mut self, on: Expr) -\u003e Self {\n        self.joins.push(Join::left::\u003cJ\u003e(on));\n        self\n    }\n    \n    // Aggregation\n    pub fn group_by(mut self, column: Expr) -\u003e Self {\n        self.group_by.push(column);\n        self\n    }\n    \n    pub fn having(mut self, expr: Expr) -\u003e Self {\n        self.having = Some(expr);\n        self\n    }\n    \n    // Modifiers\n    pub fn distinct(mut self) -\u003e Self {\n        self.distinct = true;\n        self\n    }\n    \n    pub fn for_update(mut self) -\u003e Self {\n        self.for_update = true;\n        self\n    }\n}\n```\n\n### Execution Methods\n```rust\nimpl\u003cM: Model\u003e Select\u003cM\u003e {\n    /// Build the SQL query and parameters\n    pub fn build(\u0026self, dialect: Dialect) -\u003e (String, Vec\u003cValue\u003e) {\n        let mut params = Vec::new();\n        let sql = self.to_sql(dialect, \u0026mut params);\n        (sql, params)\n    }\n    \n    /// Execute and return all matching rows\n    pub async fn all\u003cC: Connection\u003e(\n        self,\n        cx: \u0026Cx,\n        conn: \u0026C,\n    ) -\u003e Outcome\u003cVec\u003cM\u003e, Error\u003e {\n        let (sql, params) = self.build(Dialect::detect(conn));\n        let rows = conn.query(cx, \u0026sql, \u0026params).await?;\n        \n        let mut results = Vec::with_capacity(rows.len());\n        for row in rows {\n            results.push(M::from_row(\u0026row)?);\n        }\n        Outcome::Ok(results)\n    }\n    \n    /// Execute and return first matching row\n    pub async fn first\u003cC: Connection\u003e(\n        self,\n        cx: \u0026Cx,\n        conn: \u0026C,\n    ) -\u003e Outcome\u003cOption\u003cM\u003e, Error\u003e {\n        let (sql, params) = self.build(Dialect::detect(conn));\n        let row = conn.query_one(cx, \u0026sql, \u0026params).await?;\n        \n        match row {\n            Some(r) =\u003e Ok(Some(M::from_row(\u0026r)?)),\n            None =\u003e Ok(None),\n        }\n    }\n    \n    /// Execute and return row count\n    pub async fn count\u003cC: Connection\u003e(\n        self,\n        cx: \u0026Cx,\n        conn: \u0026C,\n    ) -\u003e Outcome\u003cu64, Error\u003e {\n        let count_select = Select::\u003cM\u003e {\n            columns: Some(vec![Expr::count()]),\n            ..self\n        };\n        let (sql, params) = count_select.build(Dialect::detect(conn));\n        let row = conn.query_one(cx, \u0026sql, \u0026params).await?\n            .ok_or(Error::Query(QueryError::unexpected(\"COUNT returned no rows\")))?;\n        \n        row.get_as(0)\n    }\n}\n```\n\n### SQL Generation\n```rust\nimpl\u003cM: Model\u003e Select\u003cM\u003e {\n    fn to_sql(\u0026self, dialect: Dialect, params: \u0026mut Vec\u003cValue\u003e) -\u003e String {\n        let mut sql = String::from(\"SELECT \");\n        \n        if self.distinct {\n            sql.push_str(\"DISTINCT \");\n        }\n        \n        // Columns\n        match \u0026self.columns {\n            Some(cols) =\u003e {\n                let col_strs: Vec\u003c_\u003e = cols.iter()\n                    .map(|c| c.to_sql(dialect, params))\n                    .collect();\n                sql.push_str(\u0026col_strs.join(\", \"));\n            }\n            None =\u003e {\n                // All columns from Model\n                sql.push_str(\u0026M::columns().join(\", \"));\n            }\n        }\n        \n        // FROM\n        sql.push_str(\" FROM \");\n        sql.push_str(\u0026self.table);\n        if let Some(alias) = \u0026self.alias {\n            sql.push_str(\" AS \");\n            sql.push_str(alias);\n        }\n        \n        // JOINs\n        for join in \u0026self.joins {\n            sql.push_str(\u0026join.to_sql(dialect, params));\n        }\n        \n        // WHERE\n        if let Some(filter) = \u0026self.filter {\n            sql.push_str(\" WHERE \");\n            sql.push_str(\u0026filter.to_sql(dialect, params));\n        }\n        \n        // GROUP BY\n        if !self.group_by.is_empty() {\n            sql.push_str(\" GROUP BY \");\n            let groups: Vec\u003c_\u003e = self.group_by.iter()\n                .map(|g| g.to_sql(dialect, params))\n                .collect();\n            sql.push_str(\u0026groups.join(\", \"));\n        }\n        \n        // HAVING\n        if let Some(having) = \u0026self.having {\n            sql.push_str(\" HAVING \");\n            sql.push_str(\u0026having.to_sql(dialect, params));\n        }\n        \n        // ORDER BY\n        if !self.order_by.is_empty() {\n            sql.push_str(\" ORDER BY \");\n            let orders: Vec\u003c_\u003e = self.order_by.iter()\n                .map(|o| o.to_sql())\n                .collect();\n            sql.push_str(\u0026orders.join(\", \"));\n        }\n        \n        // LIMIT\n        if let Some(n) = self.limit {\n            sql.push_str(\u0026format!(\" LIMIT {}\", n));\n        }\n        \n        // OFFSET\n        if let Some(n) = self.offset {\n            sql.push_str(\u0026format!(\" OFFSET {}\", n));\n        }\n        \n        // FOR UPDATE\n        if self.for_update {\n            sql.push_str(\" FOR UPDATE\");\n        }\n        \n        sql\n    }\n}\n```\n\n## Testing Requirements\n- Basic SELECT * FROM table\n- SELECT with WHERE\n- Multiple filters (AND)\n- ORDER BY single and multiple columns\n- LIMIT and OFFSET\n- JOINs\n- GROUP BY and HAVING\n- COUNT, SUM, etc.\n- Parameter binding\n\n## Acceptance Criteria\n- [ ] All builder methods implemented\n- [ ] SQL generation correct for all clauses\n- [ ] Execution methods work with Connection\n- [ ] Parameters properly bound\n- [ ] Works with real database (integration test)\n\n## Files to Modify\n- crates/sqlmodel-query/src/select.rs\n\n## Estimated Effort\n~350 lines of SELECT code","status":"open","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:24:25.513951749-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:24:25.513951749-05:00","dependencies":[{"issue_id":"sqlmodel_rust-6vd.2","depends_on_id":"sqlmodel_rust-6vd","type":"parent-child","created_at":"2026-01-17T11:24:25.516798961-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-6vd.2","depends_on_id":"sqlmodel_rust-6vd.1","type":"blocks","created_at":"2026-01-17T11:24:25.518851086-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-6vd.3","title":"Query: Implement INSERT, UPDATE, DELETE builders","description":"# Task: Implement INSERT, UPDATE, DELETE Builders\n\n## Context\nComplete the CRUD operations with INSERT, UPDATE, and DELETE builders that follow the same fluent API pattern as SELECT.\n\n## INSERT Builder\n\n### Usage\n```rust\n// Insert single model\nlet id = insert!(hero).execute(cx, \u0026conn).await?;\n\n// Insert and return the inserted row\nlet hero = insert!(hero).returning::\u003cHero\u003e().execute(cx, \u0026conn).await?;\n\n// Bulk insert\nlet ids = insert_many!(vec![hero1, hero2, hero3]).execute(cx, \u0026conn).await?;\n```\n\n### Implementation\n```rust\npub struct InsertBuilder\u003cM: Model\u003e {\n    model: M,\n    returning: bool,\n    on_conflict: Option\u003cOnConflict\u003e,\n}\n\npub struct InsertManyBuilder\u003cM: Model\u003e {\n    models: Vec\u003cM\u003e,\n    returning: bool,\n    on_conflict: Option\u003cOnConflict\u003e,\n}\n\npub enum OnConflict {\n    DoNothing,\n    DoUpdate { columns: Vec\u003cString\u003e },\n}\n\nimpl\u003cM: Model\u003e InsertBuilder\u003cM\u003e {\n    pub fn new(model: M) -\u003e Self;\n    \n    /// Return the inserted row (RETURNING * in PostgreSQL)\n    pub fn returning(mut self) -\u003e Self {\n        self.returning = true;\n        self\n    }\n    \n    /// Handle conflicts (UPSERT)\n    pub fn on_conflict_do_nothing(mut self) -\u003e Self {\n        self.on_conflict = Some(OnConflict::DoNothing);\n        self\n    }\n    \n    pub fn on_conflict_do_update(mut self, columns: \u0026[\u0026str]) -\u003e Self {\n        self.on_conflict = Some(OnConflict::DoUpdate {\n            columns: columns.iter().map(|s| s.to_string()).collect(),\n        });\n        self\n    }\n    \n    /// Execute and return last insert ID\n    pub async fn execute\u003cC: Connection\u003e(\n        self,\n        cx: \u0026Cx,\n        conn: \u0026C,\n    ) -\u003e Outcome\u003ci64, Error\u003e;\n    \n    fn to_sql(\u0026self, dialect: Dialect, params: \u0026mut Vec\u003cValue\u003e) -\u003e String {\n        // INSERT INTO table (col1, col2) VALUES ($1, $2)\n        let columns = M::insert_columns();\n        let values = self.model.to_insert_values();\n        \n        let mut sql = format!(\"INSERT INTO {} (\", M::TABLE_NAME);\n        sql.push_str(\u0026columns.join(\", \"));\n        sql.push_str(\") VALUES (\");\n        \n        let placeholders: Vec\u003c_\u003e = (1..=values.len())\n            .map(|i| dialect.placeholder(i))\n            .collect();\n        sql.push_str(\u0026placeholders.join(\", \"));\n        sql.push_str(\")\");\n        \n        if let Some(conflict) = \u0026self.on_conflict {\n            match conflict {\n                OnConflict::DoNothing =\u003e {\n                    sql.push_str(\" ON CONFLICT DO NOTHING\");\n                }\n                OnConflict::DoUpdate { columns } =\u003e {\n                    sql.push_str(\" ON CONFLICT DO UPDATE SET \");\n                    let updates: Vec\u003c_\u003e = columns.iter()\n                        .map(|c| format!(\"{} = EXCLUDED.{}\", c, c))\n                        .collect();\n                    sql.push_str(\u0026updates.join(\", \"));\n                }\n            }\n        }\n        \n        if self.returning {\n            sql.push_str(\" RETURNING *\");\n        }\n        \n        params.extend(values);\n        sql\n    }\n}\n```\n\n## UPDATE Builder\n\n### Usage\n```rust\n// Update model by primary key\nlet rows = update!(hero).execute(cx, \u0026conn).await?;\n\n// Update with explicit SET\nlet rows = update!(Hero)\n    .set(\"age\", 26)\n    .filter(Expr::col(\"id\").eq(42))\n    .execute(cx, \u0026conn).await?;\n```\n\n### Implementation\n```rust\npub struct UpdateBuilder\u003cM: Model\u003e {\n    model: Option\u003cM\u003e,\n    sets: Vec\u003c(String, Expr)\u003e,\n    filter: Option\u003cExpr\u003e,\n    returning: bool,\n}\n\nimpl\u003cM: Model\u003e UpdateBuilder\u003cM\u003e {\n    /// Update a model instance (uses primary key for WHERE)\n    pub fn from_model(model: M) -\u003e Self;\n    \n    /// Start a new UPDATE statement\n    pub fn new() -\u003e Self;\n    \n    /// Set a column to a value\n    pub fn set\u003cV: Into\u003cExpr\u003e\u003e(mut self, column: \u0026str, value: V) -\u003e Self {\n        self.sets.push((column.to_string(), value.into()));\n        self\n    }\n    \n    /// Add WHERE clause\n    pub fn filter(mut self, expr: Expr) -\u003e Self {\n        self.filter = Some(match self.filter {\n            Some(existing) =\u003e existing.and(expr),\n            None =\u003e expr,\n        });\n        self\n    }\n    \n    /// Return updated rows\n    pub fn returning(mut self) -\u003e Self {\n        self.returning = true;\n        self\n    }\n    \n    /// Execute and return rows affected\n    pub async fn execute\u003cC: Connection\u003e(\n        self,\n        cx: \u0026Cx,\n        conn: \u0026C,\n    ) -\u003e Outcome\u003cu64, Error\u003e;\n    \n    fn to_sql(\u0026self, dialect: Dialect, params: \u0026mut Vec\u003cValue\u003e) -\u003e String {\n        let mut sql = format!(\"UPDATE {} SET \", M::TABLE_NAME);\n        \n        if let Some(model) = \u0026self.model {\n            // Update all columns from model\n            let columns = M::update_columns();\n            let values = model.to_update_values();\n            let pk_values = model.primary_key_values();\n            \n            let sets: Vec\u003c_\u003e = columns.iter()\n                .enumerate()\n                .map(|(i, col)| {\n                    params.push(values[i].clone());\n                    format!(\"{} = {}\", col, dialect.placeholder(params.len()))\n                })\n                .collect();\n            sql.push_str(\u0026sets.join(\", \"));\n            \n            // WHERE primary key = value\n            sql.push_str(\" WHERE \");\n            let pk_clauses: Vec\u003c_\u003e = M::PRIMARY_KEY.iter()\n                .zip(pk_values.iter())\n                .map(|(col, val)| {\n                    params.push(val.clone());\n                    format!(\"{} = {}\", col, dialect.placeholder(params.len()))\n                })\n                .collect();\n            sql.push_str(\u0026pk_clauses.join(\" AND \"));\n        } else {\n            // Use explicit SET clauses\n            let sets: Vec\u003c_\u003e = self.sets.iter()\n                .map(|(col, expr)| {\n                    format!(\"{} = {}\", col, expr.to_sql(dialect, params))\n                })\n                .collect();\n            sql.push_str(\u0026sets.join(\", \"));\n            \n            if let Some(filter) = \u0026self.filter {\n                sql.push_str(\" WHERE \");\n                sql.push_str(\u0026filter.to_sql(dialect, params));\n            }\n        }\n        \n        if self.returning {\n            sql.push_str(\" RETURNING *\");\n        }\n        \n        sql\n    }\n}\n```\n\n## DELETE Builder\n\n### Usage\n```rust\n// Delete by filter\nlet rows = delete!(Hero)\n    .filter(Expr::col(\"age\").lt(18))\n    .execute(cx, \u0026conn).await?;\n\n// Delete by primary key\nlet rows = delete!(hero).execute(cx, \u0026conn).await?;\n```\n\n### Implementation\n```rust\npub struct DeleteBuilder\u003cM: Model\u003e {\n    model: Option\u003cM\u003e,\n    filter: Option\u003cExpr\u003e,\n    returning: bool,\n}\n\nimpl\u003cM: Model\u003e DeleteBuilder\u003cM\u003e {\n    pub fn new() -\u003e Self;\n    pub fn from_model(model: M) -\u003e Self;\n    \n    pub fn filter(mut self, expr: Expr) -\u003e Self;\n    pub fn returning(mut self) -\u003e Self;\n    \n    pub async fn execute\u003cC: Connection\u003e(\n        self,\n        cx: \u0026Cx,\n        conn: \u0026C,\n    ) -\u003e Outcome\u003cu64, Error\u003e;\n}\n```\n\n## Testing Requirements\n- INSERT single row, get ID\n- INSERT with RETURNING\n- Bulk INSERT\n- UPDATE by model\n- UPDATE with explicit SET\n- UPDATE with complex WHERE\n- DELETE by filter\n- DELETE by model\n- On conflict handling\n\n## Acceptance Criteria\n- [ ] INSERT single and bulk implemented\n- [ ] UPDATE by model and explicit SET\n- [ ] DELETE by filter and model\n- [ ] RETURNING clause works\n- [ ] On conflict (UPSERT) works\n- [ ] Integration tests pass\n\n## Files to Modify\n- crates/sqlmodel-query/src/builder.rs\n\n## Estimated Effort\n~350 lines of builder code","status":"open","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:24:53.885250037-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:24:53.885250037-05:00","dependencies":[{"issue_id":"sqlmodel_rust-6vd.3","depends_on_id":"sqlmodel_rust-6vd","type":"parent-child","created_at":"2026-01-17T11:24:53.886592655-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-6vd.3","depends_on_id":"sqlmodel_rust-6vd.1","type":"blocks","created_at":"2026-01-17T11:24:53.888096678-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-84w","title":"SQLModel Rust: Testing Infrastructure","description":"# Epic: Testing Infrastructure\n\n## Overview\nThis epic establishes comprehensive testing infrastructure for SQLModel Rust, including unit tests, integration tests, end-to-end tests, and performance benchmarks. All tests use asupersync's LabRuntime for deterministic async testing.\n\n## Rationale\nThorough testing is critical for a database library because:\n- SQL generation must be correct for all edge cases\n- Type conversions must be lossless and reversible\n- Protocol implementations must handle all message types\n- Concurrent access must be safe\n- Performance regressions must be caught\n\n## Key Components\n\n### 1. Unit Test Framework\nPer-crate unit tests:\n- sqlmodel-core: Value conversions, Row operations, Error formatting\n- sqlmodel-macros: Proc macro output verification\n- sqlmodel-query: SQL generation correctness\n- sqlmodel-schema: DDL generation, migration logic\n- sqlmodel-pool: Pool state management\n\n### 2. Integration Test Fixtures\nTest database setup:\n- SQLite in-memory databases\n- PostgreSQL Docker container\n- MySQL Docker container\n- Schema creation/teardown\n- Test data seeding\n\n### 3. Protocol Tests\nFor PostgreSQL and MySQL:\n- Message parsing tests (binary fixtures)\n- Message serialization tests\n- Authentication flow tests (mock server)\n- Error handling tests\n- Edge cases (large messages, binary data)\n\n### 4. CRUD Test Suite\nStandard operations across all drivers:\n- INSERT single row, multiple rows\n- SELECT with filters, joins, ordering\n- UPDATE with conditions\n- DELETE with conditions\n- Transaction commit/rollback\n- NULL handling\n- Type round-trips\n\n### 5. Concurrency Tests\nStress testing:\n- Concurrent queries on same connection\n- Connection pool under load\n- Transaction isolation verification\n- Deadlock detection/handling\n\n### 6. E2E Test Scenarios\nReal-world usage patterns:\n- Blog application (users, posts, comments)\n- E-commerce (products, orders, inventory)\n- Full CRUD lifecycle\n- Migration up/down/up cycle\n- Multi-tenant isolation\n\n### 7. Performance Benchmarks\nUsing criterion.rs:\n- Query building latency\n- Small query execution\n- Bulk insert performance\n- Connection pool throughput\n- Comparison with raw driver performance\n\n### 8. Regression Tests\nPrevent regressions:\n- Known bug reproductions\n- Edge cases discovered in production\n- Type coercion edge cases\n- SQL dialect differences\n\n### 9. Logging and Diagnostics\nTest output quality:\n- Detailed logging at TRACE level\n- Query timing information\n- Connection state logging\n- Failure diagnostics (query, params, error)\n\n## Test Organization\n```\ntests/\n unit/\n    core/\n    macros/\n    query/\n    schema/\n    pool/\n integration/\n    sqlite/\n    postgres/\n    mysql/\n e2e/\n    blog_app/\n    ecommerce/\n protocol/\n    postgres_messages/\n    mysql_messages/\n fixtures/\n    schemas/\n    data/\n benches/\n     query_building.rs\n     execution.rs\n```\n\n## Key Design Decisions\n1. **LabRuntime for async**: Deterministic, reproducible async tests\n2. **Docker for real databases**: Test against actual PostgreSQL/MySQL\n3. **In-memory SQLite for speed**: Fast unit tests\n4. **Fixture-based protocol tests**: Binary message fixtures for parsing\n5. **Property-based testing**: Use proptest for type conversions\n\n## Success Criteria\n- [ ] \u003e90% code coverage\n- [ ] All public APIs have doc tests\n- [ ] Integration tests for all CRUD operations\n- [ ] Protocol tests cover all message types\n- [ ] E2E tests validate real usage patterns\n- [ ] Benchmarks establish performance baselines\n- [ ] CI runs all tests on every commit\n- [ ] Test failures have clear diagnostic output\n\n## Dependencies\n- All sqlmodel-* crates\n- asupersync (LabRuntime)\n- criterion (benchmarks)\n- proptest (property testing)\n- testcontainers (Docker)\n\n## Estimated Scope\n~3000 lines of test code","status":"open","priority":1,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:19:38.373062215-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:19:38.373062215-05:00"}
{"id":"sqlmodel_rust-b0q","title":"SQLModel Rust: PostgreSQL Protocol Implementation","description":"# Epic: PostgreSQL Protocol Implementation (sqlmodel-postgres)\n\n## Overview\nThis epic implements the PostgreSQL wire protocol from scratch. PostgreSQL uses a well-documented TCP-based protocol with message framing. We implement this protocol directly using asupersync's TCP primitives for full control and native async integration.\n\n## Rationale\nWhy implement the protocol ourselves instead of using libpq or tokio-postgres?\n1. **Full async control**: Native asupersync integration, not adapter patterns\n2. **Cancellation support**: Protocol-level query cancellation\n3. **Zero-copy potential**: Control over buffer management\n4. **Understanding**: Know exactly what's happening on the wire\n5. **First principles**: No hidden complexity or surprising behaviors\n\n## Key Components\n\n### 1. Message Protocol (protocol.rs)\nPostgreSQL uses length-prefixed messages:\n- First byte: message type (or none for startup)\n- Next 4 bytes: length (including self)\n- Remaining: payload\n\nMessage types (frontend -\u003e backend):\n- Startup: Version, parameters\n- Query: Simple query string\n- Parse: Prepare statement\n- Bind: Bind parameters\n- Describe: Get row description\n- Execute: Run prepared\n- Sync: Synchronize\n- Terminate: Close connection\n- CancelRequest: Cancel running query\n- CopyData, CopyDone, CopyFail\n\nMessage types (backend -\u003e frontend):\n- AuthenticationXxx: Auth requirements\n- ParameterStatus: Server config\n- BackendKeyData: Cancellation key\n- ReadyForQuery: Transaction status\n- RowDescription: Column metadata\n- DataRow: Result row\n- CommandComplete: Query done\n- ErrorResponse: Error details\n- NoticeResponse: Warnings\n- ParseComplete, BindComplete, etc.\n\n### 2. Authentication (auth.rs)\nSupport multiple auth methods:\n- AuthenticationOk (trust)\n- AuthenticationCleartextPassword\n- AuthenticationMD5Password (md5(md5(password+user)+salt))\n- AuthenticationSASL (SCRAM-SHA-256)\n\nSCRAM-SHA-256 implementation:\n- Client-first message\n- Server-first message (salt, iterations)\n- Client-final message (proof)\n- Server-final message (verifier)\n\n### 3. Simple Query Protocol (simple.rs)\nFor simple one-off queries:\n- Send Query message with SQL string\n- Receive: RowDescription, DataRow*, CommandComplete, ReadyForQuery\n- Returns results as strings (text format)\n\n### 4. Extended Query Protocol (extended.rs)\nFor prepared statements and binary data:\n- Parse: Prepare named statement\n- Bind: Bind parameters to statement\n- Describe: Get result column info\n- Execute: Run with row limit\n- Sync: Flush and get ReadyForQuery\n\nBenefits:\n- Binary parameter/result format\n- Statement caching\n- Partial result fetching\n\n### 5. Type System (types.rs)\nPostgreSQL OID-based type system:\n- Map OIDs to Rust types\n- Text format encoding/decoding\n- Binary format encoding/decoding\n- Array type support\n- Composite types (future)\n- Custom types via registry\n\nCommon OIDs:\n- 16: bool\n- 21: int2\n- 23: int4\n- 20: int8\n- 700: float4\n- 701: float8\n- 25: text\n- 17: bytea\n- 1082: date\n- 1114: timestamp\n- 2950: uuid\n- 3802: jsonb\n\n### 6. Connection Management (connection.rs)\n- TCP connection establishment\n- SSL/TLS upgrade (optional)\n- Startup message with parameters\n- Authentication handshake\n- Parameter status tracking\n- Ready state management\n- Graceful termination\n\n### 7. Error Handling (error.rs)\nParse ErrorResponse fields:\n- Severity (ERROR, FATAL, PANIC)\n- SQLSTATE code (e.g., 23505 for unique violation)\n- Message, Detail, Hint\n- Position, Internal position\n- Schema, Table, Column, Constraint\n- File, Line, Routine\n\n### 8. Transactions\nPostgreSQL transaction modes:\n- BEGIN/COMMIT/ROLLBACK\n- Savepoints: SAVEPOINT, ROLLBACK TO, RELEASE\n- Isolation levels: READ COMMITTED, REPEATABLE READ, SERIALIZABLE\n- Read-only mode\n\n### 9. Query Cancellation\nProtocol-level cancellation:\n- Open new connection\n- Send CancelRequest with backend key\n- Original query receives cancellation\n\n## Key Design Decisions\n1. **Async from ground up**: Use asupersync's TCP, not sync + spawn_blocking\n2. **Connection struct**: Owns TCP stream, manages state machine\n3. **Buffer management**: Reusable read/write buffers\n4. **Statement cache**: LRU cache of prepared statements\n5. **Type registry**: Extensible OID -\u003e type mapping\n\n## Success Criteria\n- [ ] Connect to PostgreSQL server\n- [ ] All authentication methods work\n- [ ] Simple queries execute correctly\n- [ ] Extended protocol with parameters\n- [ ] Binary format for common types\n- [ ] Transactions with isolation levels\n- [ ] Query cancellation works\n- [ ] Error messages include SQLSTATE\n- [ ] SSL/TLS connections\n- [ ] Connection pooling integration\n- [ ] COPY protocol (import/export)\n- [ ] Notifications/LISTEN (future)\n\n## Dependencies\n- sqlmodel-core (Connection trait, Value, Row, Error)\n- asupersync (TCP, cancellation, Budget)\n\n## Estimated Scope\n~2500 lines of protocol implementation\n\n## References\n- PostgreSQL Protocol Documentation: https://www.postgresql.org/docs/current/protocol.html\n- SCRAM RFC: https://tools.ietf.org/html/rfc5802","status":"open","priority":0,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:18:47.384603066-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:18:47.384603066-05:00"}
{"id":"sqlmodel_rust-b0q.1","title":"Postgres: Implement message framing and parsing","description":"# Task: Implement PostgreSQL Message Framing and Parsing\n\n## Context\nPostgreSQL uses a simple message format with a type byte and length prefix. This task implements the foundational message encoding/decoding layer.\n\n## Message Format\n\n### Standard Message (after startup)\n```\n+------+--------+------------------+\n| Type | Length | Payload          |\n| 1B   | 4B     | (Length-4) bytes |\n+------+--------+------------------+\n```\n\nLength includes itself (4 bytes) but not the type byte.\n\n### Startup Message (first message from client)\n```\n+--------+------------------+\n| Length | Payload          |\n| 4B     | (Length-4) bytes |\n+--------+------------------+\n```\n\nNo type byte for startup message.\n\n## Message Types\n\n### Frontend Messages (Client -\u003e Server)\n```rust\n#[derive(Debug, Clone)]\npub enum FrontendMessage {\n    /// Startup message (no type byte)\n    Startup {\n        version: i32,    // 196608 for 3.0\n        params: Vec\u003c(String, String)\u003e,\n    },\n    \n    /// Password response\n    PasswordMessage(String),\n    \n    /// SASL authentication\n    SASLInitialResponse {\n        mechanism: String,\n        data: Vec\u003cu8\u003e,\n    },\n    SASLResponse(Vec\u003cu8\u003e),\n    \n    /// Simple query\n    Query(String),\n    \n    /// Extended query protocol\n    Parse {\n        name: String,      // \"\" for unnamed\n        query: String,\n        param_types: Vec\u003cu32\u003e,  // OIDs\n    },\n    Bind {\n        portal: String,\n        statement: String,\n        param_formats: Vec\u003ci16\u003e,  // 0=text, 1=binary\n        params: Vec\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e,  // None for NULL\n        result_formats: Vec\u003ci16\u003e,\n    },\n    Describe {\n        kind: char,  // 'S' for statement, 'P' for portal\n        name: String,\n    },\n    Execute {\n        portal: String,\n        max_rows: i32,  // 0 for all\n    },\n    Close {\n        kind: char,\n        name: String,\n    },\n    Sync,\n    Flush,\n    \n    /// Copy operations\n    CopyData(Vec\u003cu8\u003e),\n    CopyDone,\n    CopyFail(String),\n    \n    /// Terminate connection\n    Terminate,\n    \n    /// Cancel request (separate connection)\n    CancelRequest {\n        process_id: i32,\n        secret_key: i32,\n    },\n}\n```\n\n### Backend Messages (Server -\u003e Client)\n```rust\n#[derive(Debug, Clone)]\npub enum BackendMessage {\n    /// Authentication\n    AuthenticationOk,\n    AuthenticationCleartextPassword,\n    AuthenticationMD5Password([u8; 4]),  // salt\n    AuthenticationSASL(Vec\u003cString\u003e),      // mechanisms\n    AuthenticationSASLContinue(Vec\u003cu8\u003e),\n    AuthenticationSASLFinal(Vec\u003cu8\u003e),\n    \n    /// Connection info\n    BackendKeyData {\n        process_id: i32,\n        secret_key: i32,\n    },\n    ParameterStatus {\n        name: String,\n        value: String,\n    },\n    ReadyForQuery(TransactionStatus),\n    \n    /// Query results\n    RowDescription(Vec\u003cFieldDescription\u003e),\n    DataRow(Vec\u003cOption\u003cVec\u003cu8\u003e\u003e\u003e),\n    CommandComplete(String),\n    EmptyQueryResponse,\n    \n    /// Extended query responses\n    ParseComplete,\n    BindComplete,\n    CloseComplete,\n    ParameterDescription(Vec\u003cu32\u003e),\n    NoData,\n    PortalSuspended,\n    \n    /// Errors and notices\n    ErrorResponse(ErrorFields),\n    NoticeResponse(ErrorFields),\n    \n    /// Copy\n    CopyInResponse {\n        format: i8,\n        column_formats: Vec\u003ci16\u003e,\n    },\n    CopyOutResponse {\n        format: i8,\n        column_formats: Vec\u003ci16\u003e,\n    },\n    CopyData(Vec\u003cu8\u003e),\n    CopyDone,\n    \n    /// Notifications\n    NotificationResponse {\n        process_id: i32,\n        channel: String,\n        payload: String,\n    },\n}\n\n#[derive(Debug, Clone)]\npub struct FieldDescription {\n    pub name: String,\n    pub table_oid: u32,\n    pub column_id: i16,\n    pub type_oid: u32,\n    pub type_size: i16,\n    pub type_modifier: i32,\n    pub format: i16,\n}\n\n#[derive(Debug, Clone)]\npub struct ErrorFields {\n    pub severity: String,\n    pub code: String,\n    pub message: String,\n    pub detail: Option\u003cString\u003e,\n    pub hint: Option\u003cString\u003e,\n    pub position: Option\u003ci32\u003e,\n    pub internal_position: Option\u003ci32\u003e,\n    pub internal_query: Option\u003cString\u003e,\n    pub where_: Option\u003cString\u003e,\n    pub schema: Option\u003cString\u003e,\n    pub table: Option\u003cString\u003e,\n    pub column: Option\u003cString\u003e,\n    pub data_type: Option\u003cString\u003e,\n    pub constraint: Option\u003cString\u003e,\n    pub file: Option\u003cString\u003e,\n    pub line: Option\u003ci32\u003e,\n    pub routine: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum TransactionStatus {\n    Idle,         // 'I'\n    Transaction,  // 'T'\n    Error,        // 'E'\n}\n```\n\n## Implementation\n\n### Message Writer\n```rust\npub struct MessageWriter {\n    buf: Vec\u003cu8\u003e,\n}\n\nimpl MessageWriter {\n    pub fn new() -\u003e Self;\n    \n    /// Write a frontend message\n    pub fn write(\u0026mut self, msg: \u0026FrontendMessage) -\u003e \u0026[u8] {\n        self.buf.clear();\n        \n        match msg {\n            FrontendMessage::Startup { version, params } =\u003e {\n                // No type byte for startup\n                let mut body = Vec::new();\n                body.extend_from_slice(\u0026version.to_be_bytes());\n                for (key, value) in params {\n                    body.extend_from_slice(key.as_bytes());\n                    body.push(0);\n                    body.extend_from_slice(value.as_bytes());\n                    body.push(0);\n                }\n                body.push(0);  // Terminator\n                \n                let len = (body.len() + 4) as i32;\n                self.buf.extend_from_slice(\u0026len.to_be_bytes());\n                self.buf.extend(body);\n            }\n            FrontendMessage::Query(sql) =\u003e {\n                self.buf.push(b'Q');\n                let len = (sql.len() + 5) as i32;  // 4 for length + 1 for null\n                self.buf.extend_from_slice(\u0026len.to_be_bytes());\n                self.buf.extend_from_slice(sql.as_bytes());\n                self.buf.push(0);\n            }\n            // ... other messages\n        }\n        \n        \u0026self.buf\n    }\n}\n```\n\n### Message Reader\n```rust\npub struct MessageReader {\n    buf: Vec\u003cu8\u003e,\n    pos: usize,\n}\n\nimpl MessageReader {\n    /// Read a backend message from bytes\n    pub fn read(\u0026mut self, data: \u0026[u8]) -\u003e Result\u003cOption\u003cBackendMessage\u003e, Error\u003e {\n        if data.len() \u003c 5 {\n            return Ok(None);  // Need more data\n        }\n        \n        let type_byte = data[0];\n        let length = i32::from_be_bytes([data[1], data[2], data[3], data[4]]) as usize;\n        \n        if data.len() \u003c length + 1 {\n            return Ok(None);  // Need more data\n        }\n        \n        let payload = \u0026data[5..length + 1];\n        \n        let msg = match type_byte {\n            b'R' =\u003e self.parse_authentication(payload)?,\n            b'K' =\u003e self.parse_backend_key_data(payload)?,\n            b'S' =\u003e self.parse_parameter_status(payload)?,\n            b'Z' =\u003e self.parse_ready_for_query(payload)?,\n            b'T' =\u003e self.parse_row_description(payload)?,\n            b'D' =\u003e self.parse_data_row(payload)?,\n            b'C' =\u003e self.parse_command_complete(payload)?,\n            b'E' =\u003e self.parse_error_response(payload)?,\n            b'N' =\u003e self.parse_notice_response(payload)?,\n            b'1' =\u003e BackendMessage::ParseComplete,\n            b'2' =\u003e BackendMessage::BindComplete,\n            b'3' =\u003e BackendMessage::CloseComplete,\n            // ... other types\n            _ =\u003e return Err(Error::Protocol(format!(\"Unknown message type: {}\", type_byte as char))),\n        };\n        \n        Ok(Some(msg))\n    }\n    \n    fn parse_authentication(\u0026self, payload: \u0026[u8]) -\u003e Result\u003cBackendMessage, Error\u003e {\n        let auth_type = i32::from_be_bytes([payload[0], payload[1], payload[2], payload[3]]);\n        \n        match auth_type {\n            0 =\u003e Ok(BackendMessage::AuthenticationOk),\n            3 =\u003e Ok(BackendMessage::AuthenticationCleartextPassword),\n            5 =\u003e {\n                let salt = [payload[4], payload[5], payload[6], payload[7]];\n                Ok(BackendMessage::AuthenticationMD5Password(salt))\n            }\n            10 =\u003e {\n                // SASL: parse mechanism list\n                let mechanisms = self.parse_string_list(\u0026payload[4..])?;\n                Ok(BackendMessage::AuthenticationSASL(mechanisms))\n            }\n            11 =\u003e Ok(BackendMessage::AuthenticationSASLContinue(payload[4..].to_vec())),\n            12 =\u003e Ok(BackendMessage::AuthenticationSASLFinal(payload[4..].to_vec())),\n            _ =\u003e Err(Error::Protocol(format!(\"Unknown auth type: {}\", auth_type))),\n        }\n    }\n    \n    // ... other parse methods\n}\n```\n\n## Testing Requirements\n- Round-trip encode/decode for all message types\n- Parse real PostgreSQL message captures\n- Handle partial messages correctly\n- Error on malformed messages\n- Fuzz testing for robustness\n\n## Acceptance Criteria\n- [ ] All frontend messages can be encoded\n- [ ] All backend messages can be decoded\n- [ ] Partial message handling works\n- [ ] Error fields fully parsed\n- [ ] Binary fixtures for testing\n- [ ] No panics on malformed input\n\n## Files to Create\n- crates/sqlmodel-postgres/src/protocol/mod.rs\n- crates/sqlmodel-postgres/src/protocol/messages.rs\n- crates/sqlmodel-postgres/src/protocol/writer.rs\n- crates/sqlmodel-postgres/src/protocol/reader.rs\n\n## References\n- https://www.postgresql.org/docs/current/protocol-message-formats.html\n\n## Estimated Effort\n~600 lines of protocol code","status":"open","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:25:33.31913445-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:25:33.31913445-05:00","dependencies":[{"issue_id":"sqlmodel_rust-b0q.1","depends_on_id":"sqlmodel_rust-b0q","type":"parent-child","created_at":"2026-01-17T11:25:33.32043535-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-b0q.2","title":"Postgres: Implement SCRAM-SHA-256 authentication","description":"# Task: Implement SCRAM-SHA-256 Authentication\n\n## Context\nSCRAM-SHA-256 is the default authentication method in PostgreSQL 10+. It provides secure password authentication without sending the password in cleartext.\n\n## SCRAM Protocol Overview\n\n### 1. Client First Message\n```\nn,,n=\u003cusername\u003e,r=\u003cclient-nonce\u003e\n```\n\nExample: `n,,n=postgres,r=fyko+d2lbbFgONRv9qkxdawL`\n\n### 2. Server First Message\n```\nr=\u003cclient-nonce\u003e\u003cserver-nonce\u003e,s=\u003csalt-base64\u003e,i=\u003citerations\u003e\n```\n\nExample: `r=fyko+d2lbbFgONRv9qkxdawL3rfcNHYJY1ZVvWVs7j,s=QSXCR+Q6sek8bf92,i=4096`\n\n### 3. Client Final Message\n```\nc=\u003cchannel-binding\u003e,r=\u003ccombined-nonce\u003e,p=\u003cclient-proof-base64\u003e\n```\n\n### 4. Server Final Message\n```\nv=\u003cserver-signature-base64\u003e\n```\n\n## Cryptographic Operations\n\n### Key Derivation\n```\nSaltedPassword := Hi(password, salt, iterations)\nClientKey := HMAC(SaltedPassword, \"Client Key\")\nStoredKey := H(ClientKey)\nServerKey := HMAC(SaltedPassword, \"Server Key\")\n```\n\nWhere:\n- Hi = PBKDF2 with HMAC-SHA-256\n- H = SHA-256\n- HMAC = HMAC-SHA-256\n\n### Client Proof\n```\nAuthMessage := client-first-bare + \",\" + server-first + \",\" + client-final-without-proof\nClientSignature := HMAC(StoredKey, AuthMessage)\nClientProof := ClientKey XOR ClientSignature\n```\n\n### Server Signature Verification\n```\nServerSignature := HMAC(ServerKey, AuthMessage)\n```\n\n## Implementation\n\n```rust\npub struct ScramClient {\n    username: String,\n    password: String,\n    client_nonce: String,\n    \n    // State from server\n    server_nonce: Option\u003cString\u003e,\n    salt: Option\u003cVec\u003cu8\u003e\u003e,\n    iterations: Option\u003cu32\u003e,\n    \n    // Derived keys\n    salted_password: Option\u003c[u8; 32]\u003e,\n    auth_message: Option\u003cString\u003e,\n}\n\nimpl ScramClient {\n    pub fn new(username: \u0026str, password: \u0026str) -\u003e Self {\n        let client_nonce = generate_nonce();\n        Self {\n            username: username.to_string(),\n            password: password.to_string(),\n            client_nonce,\n            server_nonce: None,\n            salt: None,\n            iterations: None,\n            salted_password: None,\n            auth_message: None,\n        }\n    }\n    \n    /// Generate client-first message\n    pub fn client_first(\u0026self) -\u003e Vec\u003cu8\u003e {\n        // gs2-header: \"n,,\" (no channel binding, no authzid)\n        // client-first-message-bare: \"n=\u003cuser\u003e,r=\u003cnonce\u003e\"\n        format!(\"n,,n={},r={}\", self.username, self.client_nonce).into_bytes()\n    }\n    \n    /// Process server-first message and generate client-final\n    pub fn process_server_first(\u0026mut self, data: \u0026[u8]) -\u003e Result\u003cVec\u003cu8\u003e, Error\u003e {\n        let msg = std::str::from_utf8(data)?;\n        \n        // Parse server-first: r=\u003cnonce\u003e,s=\u003csalt\u003e,i=\u003citerations\u003e\n        let mut combined_nonce = None;\n        let mut salt = None;\n        let mut iterations = None;\n        \n        for part in msg.split(',') {\n            if let Some(value) = part.strip_prefix(\"r=\") {\n                combined_nonce = Some(value.to_string());\n            } else if let Some(value) = part.strip_prefix(\"s=\") {\n                salt = Some(base64::decode(value)?);\n            } else if let Some(value) = part.strip_prefix(\"i=\") {\n                iterations = Some(value.parse()?);\n            }\n        }\n        \n        let combined_nonce = combined_nonce.ok_or(Error::Protocol(\"Missing nonce\"))?;\n        let salt = salt.ok_or(Error::Protocol(\"Missing salt\"))?;\n        let iterations = iterations.ok_or(Error::Protocol(\"Missing iterations\"))?;\n        \n        // Verify nonce starts with our client nonce\n        if !combined_nonce.starts_with(\u0026self.client_nonce) {\n            return Err(Error::Protocol(\"Invalid server nonce\"));\n        }\n        \n        // Derive salted password using PBKDF2\n        let salted_password = pbkdf2_hmac_sha256(\n            self.password.as_bytes(),\n            \u0026salt,\n            iterations,\n        );\n        \n        // Build auth message\n        let client_first_bare = format!(\"n={},r={}\", self.username, self.client_nonce);\n        let client_final_without_proof = format!(\"c=biws,r={}\", combined_nonce);  // biws = base64(\"n,,\")\n        let auth_message = format!(\"{},{},{}\", client_first_bare, msg, client_final_without_proof);\n        \n        // Calculate client proof\n        let client_key = hmac_sha256(\u0026salted_password, b\"Client Key\");\n        let stored_key = sha256(\u0026client_key);\n        let client_signature = hmac_sha256(\u0026stored_key, auth_message.as_bytes());\n        let client_proof: Vec\u003cu8\u003e = client_key.iter()\n            .zip(client_signature.iter())\n            .map(|(a, b)| a ^ b)\n            .collect();\n        \n        // Store for verification\n        self.server_nonce = Some(combined_nonce.clone());\n        self.salted_password = Some(salted_password);\n        self.auth_message = Some(auth_message);\n        \n        // Build client-final message\n        let client_final = format!(\n            \"c=biws,r={},p={}\",\n            combined_nonce,\n            base64::encode(\u0026client_proof)\n        );\n        \n        Ok(client_final.into_bytes())\n    }\n    \n    /// Verify server-final message\n    pub fn verify_server_final(\u0026self, data: \u0026[u8]) -\u003e Result\u003c(), Error\u003e {\n        let msg = std::str::from_utf8(data)?;\n        \n        let server_signature = msg.strip_prefix(\"v=\")\n            .ok_or(Error::Protocol(\"Invalid server-final\"))?;\n        let server_signature = base64::decode(server_signature)?;\n        \n        // Calculate expected server signature\n        let salted_password = self.salted_password.as_ref()\n            .ok_or(Error::Protocol(\"Missing salted password\"))?;\n        let auth_message = self.auth_message.as_ref()\n            .ok_or(Error::Protocol(\"Missing auth message\"))?;\n        \n        let server_key = hmac_sha256(salted_password, b\"Server Key\");\n        let expected_signature = hmac_sha256(\u0026server_key, auth_message.as_bytes());\n        \n        if server_signature != expected_signature {\n            return Err(Error::Authentication(\"Server signature mismatch\"));\n        }\n        \n        Ok(())\n    }\n}\n\n// Crypto helpers (use ring or sha2 crate)\nfn pbkdf2_hmac_sha256(password: \u0026[u8], salt: \u0026[u8], iterations: u32) -\u003e [u8; 32] { ... }\nfn hmac_sha256(key: \u0026[u8], data: \u0026[u8]) -\u003e [u8; 32] { ... }\nfn sha256(data: \u0026[u8]) -\u003e [u8; 32] { ... }\nfn generate_nonce() -\u003e String { ... }\n```\n\n## Integration with Connection\n\n```rust\nasync fn authenticate(\u0026mut self, cx: \u0026Cx, method: AuthMethod) -\u003e Outcome\u003c(), Error\u003e {\n    match method {\n        AuthMethod::ScramSha256 =\u003e {\n            let mut scram = ScramClient::new(\u0026self.config.user, \u0026self.config.password);\n            \n            // Send SASL initial response\n            self.send(FrontendMessage::SASLInitialResponse {\n                mechanism: \"SCRAM-SHA-256\".to_string(),\n                data: scram.client_first(),\n            }).await?;\n            \n            // Receive SASL continue\n            let msg = self.receive().await?;\n            let data = match msg {\n                BackendMessage::AuthenticationSASLContinue(data) =\u003e data,\n                _ =\u003e return Err(Error::Protocol(\"Expected SASL continue\")),\n            };\n            \n            // Send SASL response\n            let response = scram.process_server_first(\u0026data)?;\n            self.send(FrontendMessage::SASLResponse(response)).await?;\n            \n            // Receive SASL final\n            let msg = self.receive().await?;\n            let data = match msg {\n                BackendMessage::AuthenticationSASLFinal(data) =\u003e data,\n                _ =\u003e return Err(Error::Protocol(\"Expected SASL final\")),\n            };\n            \n            // Verify server\n            scram.verify_server_final(\u0026data)?;\n            \n            // Should receive AuthenticationOk next\n            let msg = self.receive().await?;\n            match msg {\n                BackendMessage::AuthenticationOk =\u003e Ok(()),\n                _ =\u003e Err(Error::Protocol(\"Expected AuthenticationOk\")),\n            }\n        }\n        // ... other methods\n    }\n}\n```\n\n## Testing Requirements\n- Test against known SCRAM test vectors\n- Test with real PostgreSQL server\n- Test invalid password handling\n- Test nonce validation\n- Test signature verification\n\n## Acceptance Criteria\n- [ ] SCRAM-SHA-256 complete implementation\n- [ ] Passes RFC 5802 test vectors\n- [ ] Works with PostgreSQL 10+\n- [ ] Clear error on auth failure\n- [ ] Channel binding support (future)\n\n## Dependencies\n- sqlmodel_rust-b0q.1 (message framing)\n\n## Files to Create\n- crates/sqlmodel-postgres/src/auth/mod.rs\n- crates/sqlmodel-postgres/src/auth/scram.rs\n\n## References\n- RFC 5802: SCRAM\n- RFC 7677: SCRAM-SHA-256\n\n## Estimated Effort\n~300 lines of auth code","status":"open","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:26:10.842607409-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:26:10.842607409-05:00","dependencies":[{"issue_id":"sqlmodel_rust-b0q.2","depends_on_id":"sqlmodel_rust-b0q","type":"parent-child","created_at":"2026-01-17T11:26:10.843999991-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-b0q.2","depends_on_id":"sqlmodel_rust-b0q.1","type":"blocks","created_at":"2026-01-17T11:26:10.8792044-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-b0q.3","title":"Postgres: Implement connection establishment and state machine","description":"# Task: Implement PostgreSQL Connection and State Machine\n\n## Context\nThe PostgreSQL connection manages the TCP socket, handles the startup sequence, tracks transaction state, and maintains protocol state. This is the core of the driver.\n\n## Connection State Machine\n\n### States\n```\nDisconnected -\u003e Connecting -\u003e Authenticating -\u003e Ready -\u003e InQuery -\u003e Ready\n                                                     \\-\u003e InTransaction -\u003e Ready\n```\n\n### State Transitions\n```rust\n#[derive(Debug, Clone, Copy)]\npub enum ConnectionState {\n    Disconnected,\n    Connecting,\n    Authenticating,\n    Ready(TransactionStatus),\n    InQuery,\n    InTransaction(TransactionStatus),\n    Error,\n    Closed,\n}\n\n#[derive(Debug, Clone, Copy)]\npub enum TransactionStatus {\n    Idle,        // 'I' - no transaction\n    InTrans,     // 'T' - in transaction\n    InFailed,    // 'E' - in failed transaction\n}\n```\n\n## Implementation\n\n### Connection Struct\n```rust\npub struct PgConnection {\n    /// TCP stream (owned by asupersync)\n    stream: TcpStream,\n    \n    /// Current state\n    state: ConnectionState,\n    \n    /// Backend process ID (for cancellation)\n    process_id: i32,\n    \n    /// Secret key (for cancellation)\n    secret_key: i32,\n    \n    /// Server parameters (received after startup)\n    parameters: HashMap\u003cString, String\u003e,\n    \n    /// Connection configuration\n    config: PgConfig,\n    \n    /// Read buffer\n    read_buf: Vec\u003cu8\u003e,\n    \n    /// Write buffer\n    write_buf: Vec\u003cu8\u003e,\n    \n    /// Message writer\n    writer: MessageWriter,\n    \n    /// Prepared statement cache\n    statements: LruCache\u003cString, PreparedStatement\u003e,\n}\n\npub struct PgConfig {\n    pub host: String,\n    pub port: u16,\n    pub user: String,\n    pub password: Option\u003cString\u003e,\n    pub database: String,\n    pub application_name: Option\u003cString\u003e,\n    pub connect_timeout: Duration,\n    pub ssl_mode: SslMode,\n    pub options: HashMap\u003cString, String\u003e,\n}\n```\n\n### Connection Establishment\n```rust\nimpl PgConnection {\n    pub async fn connect(cx: \u0026Cx, config: PgConfig) -\u003e Outcome\u003cSelf, Error\u003e {\n        // 1. TCP connect with timeout\n        let stream = cx.with_budget(config.connect_timeout, async {\n            TcpStream::connect(\u0026format!(\"{}:{}\", config.host, config.port)).await\n        }).await?;\n        \n        let mut conn = Self {\n            stream,\n            state: ConnectionState::Connecting,\n            process_id: 0,\n            secret_key: 0,\n            parameters: HashMap::new(),\n            config,\n            read_buf: Vec::with_capacity(8192),\n            write_buf: Vec::with_capacity(8192),\n            writer: MessageWriter::new(),\n            statements: LruCache::new(100),\n        };\n        \n        // 2. SSL negotiation (if configured)\n        if conn.config.ssl_mode != SslMode::Disable {\n            conn.negotiate_ssl(cx).await?;\n        }\n        \n        // 3. Send startup message\n        conn.send_startup(cx).await?;\n        \n        // 4. Handle authentication\n        conn.state = ConnectionState::Authenticating;\n        conn.handle_auth(cx).await?;\n        \n        // 5. Read remaining startup messages\n        conn.read_startup_messages(cx).await?;\n        \n        conn.state = ConnectionState::Ready(TransactionStatus::Idle);\n        Outcome::Ok(conn)\n    }\n    \n    async fn send_startup(\u0026mut self, cx: \u0026Cx) -\u003e Outcome\u003c(), Error\u003e {\n        let mut params = vec![\n            (\"user\".to_string(), self.config.user.clone()),\n            (\"database\".to_string(), self.config.database.clone()),\n            (\"client_encoding\".to_string(), \"UTF8\".to_string()),\n        ];\n        \n        if let Some(app) = \u0026self.config.application_name {\n            params.push((\"application_name\".to_string(), app.clone()));\n        }\n        \n        for (k, v) in \u0026self.config.options {\n            params.push((k.clone(), v.clone()));\n        }\n        \n        let msg = FrontendMessage::Startup {\n            version: 196608,  // 3.0\n            params,\n        };\n        \n        self.send_message(cx, \u0026msg).await\n    }\n    \n    async fn handle_auth(\u0026mut self, cx: \u0026Cx) -\u003e Outcome\u003c(), Error\u003e {\n        loop {\n            let msg = self.receive_message(cx).await?;\n            \n            match msg {\n                BackendMessage::AuthenticationOk =\u003e {\n                    return Outcome::Ok(());\n                }\n                BackendMessage::AuthenticationCleartextPassword =\u003e {\n                    let password = self.config.password.as_ref()\n                        .ok_or(Error::Authentication(\"Password required\"))?;\n                    self.send_message(cx, \u0026FrontendMessage::PasswordMessage(password.clone())).await?;\n                }\n                BackendMessage::AuthenticationMD5Password(salt) =\u003e {\n                    let password = self.config.password.as_ref()\n                        .ok_or(Error::Authentication(\"Password required\"))?;\n                    let hash = md5_password(\u0026self.config.user, password, \u0026salt);\n                    self.send_message(cx, \u0026FrontendMessage::PasswordMessage(hash)).await?;\n                }\n                BackendMessage::AuthenticationSASL(mechanisms) =\u003e {\n                    if mechanisms.contains(\u0026\"SCRAM-SHA-256\".to_string()) {\n                        self.scram_auth(cx).await?;\n                    } else {\n                        return Outcome::Err(Error::Authentication(\"Unsupported SASL mechanism\"));\n                    }\n                }\n                BackendMessage::ErrorResponse(e) =\u003e {\n                    return Outcome::Err(Error::from_pg_error(e));\n                }\n                _ =\u003e {\n                    return Outcome::Err(Error::Protocol(format!(\"Unexpected message during auth: {:?}\", msg)));\n                }\n            }\n        }\n    }\n    \n    async fn read_startup_messages(\u0026mut self, cx: \u0026Cx) -\u003e Outcome\u003c(), Error\u003e {\n        loop {\n            let msg = self.receive_message(cx).await?;\n            \n            match msg {\n                BackendMessage::BackendKeyData { process_id, secret_key } =\u003e {\n                    self.process_id = process_id;\n                    self.secret_key = secret_key;\n                }\n                BackendMessage::ParameterStatus { name, value } =\u003e {\n                    self.parameters.insert(name, value);\n                }\n                BackendMessage::ReadyForQuery(status) =\u003e {\n                    self.state = ConnectionState::Ready(status.into());\n                    return Outcome::Ok(());\n                }\n                BackendMessage::ErrorResponse(e) =\u003e {\n                    return Outcome::Err(Error::from_pg_error(e));\n                }\n                BackendMessage::NoticeResponse(_) =\u003e {\n                    // Log but continue\n                }\n                _ =\u003e {\n                    return Outcome::Err(Error::Protocol(format!(\"Unexpected startup message: {:?}\", msg)));\n                }\n            }\n        }\n    }\n}\n```\n\n### Low-Level I/O\n```rust\nimpl PgConnection {\n    async fn send_message(\u0026mut self, cx: \u0026Cx, msg: \u0026FrontendMessage) -\u003e Outcome\u003c(), Error\u003e {\n        cx.checkpoint()?;\n        \n        let data = self.writer.write(msg);\n        self.stream.write_all(data).await?;\n        self.stream.flush().await?;\n        \n        Outcome::Ok(())\n    }\n    \n    async fn receive_message(\u0026mut self, cx: \u0026Cx) -\u003e Outcome\u003cBackendMessage, Error\u003e {\n        cx.checkpoint()?;\n        \n        // Read header (5 bytes: type + length)\n        while self.read_buf.len() \u003c 5 {\n            let n = self.stream.read_buf(\u0026mut self.read_buf).await?;\n            if n == 0 {\n                return Outcome::Err(Error::Connection(ConnectionError::disconnected()));\n            }\n        }\n        \n        let length = i32::from_be_bytes([\n            self.read_buf[1],\n            self.read_buf[2], \n            self.read_buf[3],\n            self.read_buf[4],\n        ]) as usize;\n        \n        // Read full message\n        while self.read_buf.len() \u003c length + 1 {\n            let n = self.stream.read_buf(\u0026mut self.read_buf).await?;\n            if n == 0 {\n                return Outcome::Err(Error::Connection(ConnectionError::disconnected()));\n            }\n        }\n        \n        // Parse message\n        let msg_data = \u0026self.read_buf[..length + 1];\n        let msg = MessageReader::parse(msg_data)?;\n        \n        // Remove from buffer\n        self.read_buf.drain(..length + 1);\n        \n        Outcome::Ok(msg)\n    }\n}\n```\n\n## Testing Requirements\n- Connect to real PostgreSQL\n- Test all auth methods\n- Test connection timeout\n- Test connection loss handling\n- Test parameter negotiation\n\n## Acceptance Criteria\n- [ ] TCP connection with timeout\n- [ ] SSL negotiation\n- [ ] All auth methods supported\n- [ ] Backend key stored for cancellation\n- [ ] Server parameters captured\n- [ ] ReadyForQuery state tracking\n- [ ] Clean error handling\n\n## Dependencies\n- sqlmodel_rust-b0q.1 (messages)\n- sqlmodel_rust-b0q.2 (SCRAM)\n\n## Files to Create\n- crates/sqlmodel-postgres/src/connection.rs\n- crates/sqlmodel-postgres/src/config.rs\n\n## Estimated Effort\n~500 lines of connection code","status":"open","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:26:46.947314017-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:26:46.947314017-05:00","dependencies":[{"issue_id":"sqlmodel_rust-b0q.3","depends_on_id":"sqlmodel_rust-b0q","type":"parent-child","created_at":"2026-01-17T11:26:46.949049765-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-b0q.3","depends_on_id":"sqlmodel_rust-b0q.1","type":"blocks","created_at":"2026-01-17T11:26:46.951667495-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-b0q.3","depends_on_id":"sqlmodel_rust-b0q.2","type":"blocks","created_at":"2026-01-17T11:26:46.953627196-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-b0q.4","title":"Postgres: Implement type system and OID mapping","description":"# Task: Implement PostgreSQL Type System and OID Mapping\n\n## Context\nPostgreSQL uses OIDs (Object IDs) to identify types. We need to map these OIDs to Rust types and handle both text and binary encoding formats.\n\n## Common Type OIDs\n\n```rust\npub mod oid {\n    pub const BOOL: u32 = 16;\n    pub const BYTEA: u32 = 17;\n    pub const CHAR: u32 = 18;\n    pub const INT8: u32 = 20;\n    pub const INT2: u32 = 21;\n    pub const INT4: u32 = 23;\n    pub const TEXT: u32 = 25;\n    pub const OID: u32 = 26;\n    pub const JSON: u32 = 114;\n    pub const FLOAT4: u32 = 700;\n    pub const FLOAT8: u32 = 701;\n    pub const VARCHAR: u32 = 1043;\n    pub const DATE: u32 = 1082;\n    pub const TIME: u32 = 1083;\n    pub const TIMESTAMP: u32 = 1114;\n    pub const TIMESTAMPTZ: u32 = 1184;\n    pub const INTERVAL: u32 = 1186;\n    pub const NUMERIC: u32 = 1700;\n    pub const UUID: u32 = 2950;\n    pub const JSONB: u32 = 3802;\n    \n    // Array types (OID + 1 usually, but not always)\n    pub const BOOL_ARRAY: u32 = 1000;\n    pub const INT2_ARRAY: u32 = 1005;\n    pub const INT4_ARRAY: u32 = 1007;\n    pub const INT8_ARRAY: u32 = 1016;\n    pub const TEXT_ARRAY: u32 = 1009;\n    pub const FLOAT4_ARRAY: u32 = 1021;\n    pub const FLOAT8_ARRAY: u32 = 1022;\n}\n```\n\n## Type Registry\n\n```rust\npub struct TypeRegistry {\n    /// OID -\u003e Type info\n    types: HashMap\u003cu32, TypeInfo\u003e,\n    /// Name -\u003e OID for lookups\n    names: HashMap\u003cString, u32\u003e,\n}\n\npub struct TypeInfo {\n    pub oid: u32,\n    pub name: String,\n    pub array_oid: Option\u003cu32\u003e,\n    pub element_oid: Option\u003cu32\u003e,  // For arrays\n    pub category: TypeCategory,\n}\n\npub enum TypeCategory {\n    Boolean,\n    Numeric,\n    String,\n    DateTime,\n    Binary,\n    Json,\n    Uuid,\n    Array,\n    Composite,\n    Unknown,\n}\n\nimpl TypeRegistry {\n    pub fn new() -\u003e Self {\n        let mut registry = Self {\n            types: HashMap::new(),\n            names: HashMap::new(),\n        };\n        \n        // Register built-in types\n        registry.register(TypeInfo {\n            oid: oid::BOOL,\n            name: \"bool\".to_string(),\n            array_oid: Some(oid::BOOL_ARRAY),\n            element_oid: None,\n            category: TypeCategory::Boolean,\n        });\n        // ... register all built-in types\n        \n        registry\n    }\n    \n    pub fn get(\u0026self, oid: u32) -\u003e Option\u003c\u0026TypeInfo\u003e {\n        self.types.get(\u0026oid)\n    }\n    \n    pub fn by_name(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026TypeInfo\u003e {\n        self.names.get(name).and_then(|oid| self.types.get(oid))\n    }\n}\n```\n\n## Value Encoding/Decoding\n\n### Text Format\n\n```rust\npub trait TextEncode {\n    fn encode_text(\u0026self) -\u003e String;\n}\n\npub trait TextDecode: Sized {\n    fn decode_text(s: \u0026str) -\u003e Result\u003cSelf, Error\u003e;\n}\n\n// Implementations\nimpl TextEncode for bool {\n    fn encode_text(\u0026self) -\u003e String {\n        if *self { \"t\" } else { \"f\" }.to_string()\n    }\n}\n\nimpl TextDecode for bool {\n    fn decode_text(s: \u0026str) -\u003e Result\u003cSelf, Error\u003e {\n        match s {\n            \"t\" | \"true\" | \"1\" =\u003e Ok(true),\n            \"f\" | \"false\" | \"0\" =\u003e Ok(false),\n            _ =\u003e Err(Error::Type(TypeError::bool(s))),\n        }\n    }\n}\n\nimpl TextEncode for i32 {\n    fn encode_text(\u0026self) -\u003e String {\n        self.to_string()\n    }\n}\n\nimpl TextDecode for i32 {\n    fn decode_text(s: \u0026str) -\u003e Result\u003cSelf, Error\u003e {\n        s.parse().map_err(|_| Error::Type(TypeError::int(s)))\n    }\n}\n\n// Timestamp: \"2023-01-15 10:30:00\"\nimpl TextDecode for NaiveDateTime {\n    fn decode_text(s: \u0026str) -\u003e Result\u003cSelf, Error\u003e {\n        // Try multiple formats\n        for fmt in \u0026[\"%Y-%m-%d %H:%M:%S%.f\", \"%Y-%m-%d %H:%M:%S\", \"%Y-%m-%dT%H:%M:%S%.f\"] {\n            if let Ok(dt) = NaiveDateTime::parse_from_str(s, fmt) {\n                return Ok(dt);\n            }\n        }\n        Err(Error::Type(TypeError::datetime(s)))\n    }\n}\n```\n\n### Binary Format\n\n```rust\npub trait BinaryEncode {\n    fn encode_binary(\u0026self, buf: \u0026mut Vec\u003cu8\u003e);\n}\n\npub trait BinaryDecode: Sized {\n    fn decode_binary(data: \u0026[u8]) -\u003e Result\u003cSelf, Error\u003e;\n}\n\n// Integer types: big-endian encoding\nimpl BinaryEncode for i16 {\n    fn encode_binary(\u0026self, buf: \u0026mut Vec\u003cu8\u003e) {\n        buf.extend_from_slice(\u0026self.to_be_bytes());\n    }\n}\n\nimpl BinaryDecode for i16 {\n    fn decode_binary(data: \u0026[u8]) -\u003e Result\u003cSelf, Error\u003e {\n        if data.len() != 2 {\n            return Err(Error::Type(TypeError::binary_length(2, data.len())));\n        }\n        Ok(i16::from_be_bytes([data[0], data[1]]))\n    }\n}\n\nimpl BinaryEncode for i32 {\n    fn encode_binary(\u0026self, buf: \u0026mut Vec\u003cu8\u003e) {\n        buf.extend_from_slice(\u0026self.to_be_bytes());\n    }\n}\n\nimpl BinaryDecode for i32 {\n    fn decode_binary(data: \u0026[u8]) -\u003e Result\u003cSelf, Error\u003e {\n        if data.len() != 4 {\n            return Err(Error::Type(TypeError::binary_length(4, data.len())));\n        }\n        Ok(i32::from_be_bytes([data[0], data[1], data[2], data[3]]))\n    }\n}\n\n// Bool: single byte\nimpl BinaryEncode for bool {\n    fn encode_binary(\u0026self, buf: \u0026mut Vec\u003cu8\u003e) {\n        buf.push(if *self { 1 } else { 0 });\n    }\n}\n\nimpl BinaryDecode for bool {\n    fn decode_binary(data: \u0026[u8]) -\u003e Result\u003cSelf, Error\u003e {\n        if data.len() != 1 {\n            return Err(Error::Type(TypeError::binary_length(1, data.len())));\n        }\n        Ok(data[0] != 0)\n    }\n}\n\n// UUID: 16 bytes\nimpl BinaryEncode for Uuid {\n    fn encode_binary(\u0026self, buf: \u0026mut Vec\u003cu8\u003e) {\n        buf.extend_from_slice(self.as_bytes());\n    }\n}\n\nimpl BinaryDecode for Uuid {\n    fn decode_binary(data: \u0026[u8]) -\u003e Result\u003cSelf, Error\u003e {\n        if data.len() != 16 {\n            return Err(Error::Type(TypeError::binary_length(16, data.len())));\n        }\n        Ok(Uuid::from_bytes([\n            data[0], data[1], data[2], data[3],\n            data[4], data[5], data[6], data[7],\n            data[8], data[9], data[10], data[11],\n            data[12], data[13], data[14], data[15],\n        ]))\n    }\n}\n\n// Timestamp: microseconds since 2000-01-01\nimpl BinaryEncode for NaiveDateTime {\n    fn encode_binary(\u0026self, buf: \u0026mut Vec\u003cu8\u003e) {\n        let epoch = NaiveDateTime::parse_from_str(\"2000-01-01 00:00:00\", \"%Y-%m-%d %H:%M:%S\").unwrap();\n        let micros = (*self - epoch).num_microseconds().unwrap_or(0);\n        buf.extend_from_slice(\u0026micros.to_be_bytes());\n    }\n}\n\nimpl BinaryDecode for NaiveDateTime {\n    fn decode_binary(data: \u0026[u8]) -\u003e Result\u003cSelf, Error\u003e {\n        let micros = i64::decode_binary(data)?;\n        let epoch = NaiveDateTime::parse_from_str(\"2000-01-01 00:00:00\", \"%Y-%m-%d %H:%M:%S\").unwrap();\n        Ok(epoch + chrono::Duration::microseconds(micros))\n    }\n}\n```\n\n### Value Conversion\n\n```rust\npub fn decode_value(oid: u32, data: Option\u003c\u0026[u8]\u003e, format: Format) -\u003e Result\u003cValue, Error\u003e {\n    let Some(data) = data else {\n        return Ok(Value::Null);\n    };\n    \n    match (oid, format) {\n        (oid::BOOL, Format::Binary) =\u003e Ok(Value::Bool(bool::decode_binary(data)?)),\n        (oid::BOOL, Format::Text) =\u003e Ok(Value::Bool(bool::decode_text(std::str::from_utf8(data)?)?)),\n        \n        (oid::INT2, Format::Binary) =\u003e Ok(Value::SmallInt(i16::decode_binary(data)?)),\n        (oid::INT2, Format::Text) =\u003e Ok(Value::SmallInt(i16::decode_text(std::str::from_utf8(data)?)?)),\n        \n        (oid::INT4, Format::Binary) =\u003e Ok(Value::Integer(i32::decode_binary(data)?)),\n        (oid::INT4, Format::Text) =\u003e Ok(Value::Integer(i32::decode_text(std::str::from_utf8(data)?)?)),\n        \n        (oid::INT8, Format::Binary) =\u003e Ok(Value::BigInt(i64::decode_binary(data)?)),\n        (oid::INT8, Format::Text) =\u003e Ok(Value::BigInt(i64::decode_text(std::str::from_utf8(data)?)?)),\n        \n        (oid::TEXT | oid::VARCHAR, _) =\u003e Ok(Value::Text(String::from_utf8(data.to_vec())?)),\n        \n        (oid::BYTEA, Format::Binary) =\u003e Ok(Value::Blob(data.to_vec())),\n        (oid::BYTEA, Format::Text) =\u003e Ok(Value::Blob(decode_bytea_hex(data)?)),\n        \n        (oid::UUID, Format::Binary) =\u003e Ok(Value::Uuid(Uuid::decode_binary(data)?.into_bytes())),\n        (oid::UUID, Format::Text) =\u003e Ok(Value::Uuid(Uuid::parse_str(std::str::from_utf8(data)?)?.into_bytes())),\n        \n        // ... more types\n        \n        _ =\u003e Err(Error::Type(TypeError::unknown_oid(oid))),\n    }\n}\n```\n\n## Testing Requirements\n- Round-trip all types in text format\n- Round-trip all types in binary format\n- NULL handling\n- Edge cases (empty strings, zero dates)\n- Unknown OID handling\n\n## Acceptance Criteria\n- [ ] All common OIDs mapped\n- [ ] Text encode/decode for all types\n- [ ] Binary encode/decode for all types\n- [ ] Type registry with lookups\n- [ ] Timestamp epoch handling correct\n- [ ] Array type support\n\n## Files to Create\n- crates/sqlmodel-postgres/src/types/mod.rs\n- crates/sqlmodel-postgres/src/types/oid.rs\n- crates/sqlmodel-postgres/src/types/encode.rs\n- crates/sqlmodel-postgres/src/types/decode.rs\n\n## Estimated Effort\n~500 lines of type code","status":"open","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:27:23.943557487-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:27:23.943557487-05:00","dependencies":[{"issue_id":"sqlmodel_rust-b0q.4","depends_on_id":"sqlmodel_rust-b0q","type":"parent-child","created_at":"2026-01-17T11:27:23.944825024-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-dp9","title":"SQLModel Rust: Schema \u0026 Migrations Layer","description":"# Epic: Schema \u0026 Migrations Layer (sqlmodel-schema)\n\n## Overview\nThis epic implements DDL generation (CREATE TABLE, ALTER TABLE) and a migration system for managing database schema changes over time. Unlike SQLAlchemy's Alembic which auto-generates migrations, we use explicit up/down SQL scripts for predictability.\n\n## Rationale\nPython SQLModel inherits SQLAlchemy's complex migration system (Alembic) which:\n- Auto-detects schema differences\n- Generates migration scripts\n- Has complex dependency resolution\n\nFor Rust, we take a simpler approach:\n- Explicit migrations with up/down SQL\n- Simple linear execution order (timestamp-based IDs)\n- Migration tracking in dedicated table\n- Database introspection for validation\n\n## Key Components\n\n### 1. CREATE TABLE Generation (create.rs)\nGenerate CREATE TABLE from Model type:\n- Column definitions with types\n- NOT NULL constraints\n- PRIMARY KEY (single and composite)\n- FOREIGN KEY with ON DELETE/UPDATE\n- UNIQUE constraints\n- DEFAULT values\n- CHECK constraints (future)\n\nDialect differences handled:\n- SQLite: INTEGER PRIMARY KEY AUTOINCREMENT\n- PostgreSQL: SERIAL/BIGSERIAL, UUID\n- MySQL: AUTO_INCREMENT\n\n### 2. Migration System (migrate.rs)\nMigration management:\n- Migration struct: { id, description, up, down }\n- MigrationRunner: manages migration lifecycle\n- Tracking table: _sqlmodel_migrations\n- Operations: migrate (apply pending), rollback (revert last), status (show state)\n\n### 3. Database Introspection (introspect.rs)\nQuery database schema:\n- List tables\n- Get column info (name, type, nullable, default, pk)\n- Get foreign keys\n- Get indexes\n- Compare schema to Model (drift detection)\n\nDialect-specific queries:\n- SQLite: PRAGMA table_info, sqlite_master\n- PostgreSQL: information_schema\n- MySQL: INFORMATION_SCHEMA, SHOW commands\n\n## Key Design Decisions\n1. **Explicit over implicit**: No auto-migration generation; developers write SQL\n2. **Linear migrations**: Simple timestamp ordering, no complex DAG\n3. **Reversible by default**: Every migration has up AND down\n4. **Tracking table**: Store migration state in database itself\n5. **Dialect-aware DDL**: Generate correct syntax for target database\n\n## Success Criteria\n- [ ] CREATE TABLE generates valid SQL for all supported types\n- [ ] Primary key (simple and composite) supported\n- [ ] Foreign keys with referential actions\n- [ ] Unique constraints and indexes\n- [ ] Migration runner applies/rolls back correctly\n- [ ] Status shows pending/applied migrations\n- [ ] Introspection matches CREATE TABLE output\n- [ ] Works transactionally (all-or-nothing per migration)\n\n## Dependencies\n- sqlmodel-core (Connection, Model, FieldInfo)\n\n## Estimated Scope\n~700 lines of schema/migration code","status":"open","priority":0,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:17:40.656452843-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:17:40.656452843-05:00"}
{"id":"sqlmodel_rust-pvx","title":"SQLModel Rust: Connection Pooling Layer","description":"# Epic: Connection Pooling Layer (sqlmodel-pool)\n\n## Overview\nThis epic implements connection pooling for efficient database connection management. Pools maintain a set of open connections that can be reused across requests, avoiding the overhead of establishing new connections for each query.\n\n## Rationale\nPython SQLAlchemy uses connection pooling internally. For Rust, we build our own using asupersync primitives:\n- Channels for connection queue\n- Budget for timeout management\n- Cx for cancellation support\n\n## Key Components\n\n### 1. Pool Configuration\n- min_connections: Minimum idle connections to maintain\n- max_connections: Maximum total connections\n- acquire_timeout: Max wait time for connection\n- idle_timeout: Close connections idle longer than this\n- max_lifetime: Close connections older than this\n- test_on_borrow: Validate connection before use\n- test_on_return: Validate connection when returned\n\n### 2. Pool Core\n- Connection acquisition with timeout\n- Connection release back to pool\n- Lazy connection creation\n- Connection validation (ping/simple query)\n\n### 3. Pool Health Management\n- Periodic health check of idle connections\n- Remove dead/invalid connections\n- Replenish to min_connections\n- Connection age tracking\n\n### 4. Pool Statistics\n- total_connections: Current pool size\n- idle_connections: Available connections\n- active_connections: In-use connections\n- wait_count: Waiters in queue\n- acquire_latency: Connection acquire timing\n\n### 5. PooledConnection Wrapper\n- RAII wrapper that returns connection on drop\n- Transparent Connection trait delegation\n- Prevents direct connection access\n\n## asupersync Integration\n- Use channels for connection queue\n- Budget for acquire timeout\n- Cx context for cancellation\n- Spawn background health check task\n\n## Key Design Decisions\n1. **Generic over connection type**: Pool\u003cC: Connection\u003e\n2. **RAII for connection return**: PooledConnection drops back to pool\n3. **Lazy initialization**: Create connections on demand up to max\n4. **Background maintenance**: Async task for health checks\n5. **Graceful shutdown**: Close all connections on pool drop\n\n## Success Criteria\n- [ ] Pool respects min/max connection limits\n- [ ] Acquire waits correctly with timeout\n- [ ] Connections returned to pool on drop\n- [ ] Health checks remove invalid connections\n- [ ] Idle timeout closes unused connections\n- [ ] Statistics accurately reflect pool state\n- [ ] Works correctly under concurrent load\n- [ ] Graceful handling of connection failures\n\n## Dependencies\n- sqlmodel-core (Connection trait)\n- asupersync (channels, spawn, Budget)\n\n## Estimated Scope\n~500 lines of pooling code","status":"open","priority":1,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:17:57.125893231-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:17:57.125893231-05:00"}
{"id":"sqlmodel_rust-t9h","title":"SQLModel Rust: Derive Macros Layer","description":"# Epic: Derive Macros Layer (sqlmodel-macros)\n\n## Overview\nThis epic implements the #[derive(Model)] proc macro that transforms plain Rust structs into full ORM models. This is the Rust equivalent of Python SQLModel's metaclass magic combined with Pydantic's field introspection.\n\n## Rationale\nIn Python, SQLModel uses:\n- Pydantic's BaseModel metaclass for field discovery and validation\n- SQLAlchemy's declarative_base for ORM mapping\n- Runtime __annotations__ inspection\n\nIn Rust, we achieve the same with compile-time proc macros:\n- Parse struct definition at compile time\n- Generate Model trait implementation\n- Generate field metadata (FieldInfo)\n- Generate from_row/to_values conversions\n- Zero runtime overhead\n\n## Key Design Decisions\n1. **Attribute-driven configuration**: Use #[sqlmodel(...)] attributes for:\n   - table = \"name\" (custom table name)\n   - primary_key (mark PK fields)\n   - auto_increment (auto-generated values)\n   - nullable (Option\u003cT\u003e handling)\n   - foreign_key = \"table.column\"\n   - unique, default, index\n\n2. **Type inference**: Automatically map Rust types to SQL types:\n   - i32 -\u003e INTEGER\n   - i64 -\u003e BIGINT\n   - String -\u003e TEXT\n   - Option\u003cT\u003e -\u003e nullable T\n   - Vec\u003cu8\u003e -\u003e BLOB\n\n3. **Compile-time validation**: Error at compile time for:\n   - Invalid attribute combinations\n   - Unsupported types\n   - Missing primary key (when required)\n\n## Success Criteria\n- [ ] #[derive(Model)] generates complete Model impl\n- [ ] All field attributes parsed and validated\n- [ ] Correct SQL type inference for all Rust primitives\n- [ ] from_row correctly handles NULL values\n- [ ] to_values produces correct parameter ordering\n- [ ] Helpful compile-time error messages\n- [ ] Works with generics (where sensible)\n\n## Dependencies\n- sqlmodel-core (for Model trait, FieldInfo, etc.)\n- syn, quote, proc-macro2 (proc macro infrastructure)\n\n## Estimated Scope\n~800 lines of proc macro code","status":"open","priority":0,"issue_type":"epic","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:17:06.139824724-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:17:06.139824724-05:00"}
{"id":"sqlmodel_rust-t9h.1","title":"Macros: Parse struct and attributes in derive","description":"# Task: Parse Struct and Attributes in Derive Macro\n\n## Context\nThe first step in the Model derive macro is parsing the input struct and extracting all the #[sqlmodel(...)] attributes. This provides the foundation for code generation.\n\n## Required Parsing\n\n### Struct-Level Attributes\n```rust\n#[derive(Model)]\n#[sqlmodel(table = \"heroes\")]  // Custom table name\n#[sqlmodel(table_alias = \"h\")] // Query alias (optional)\nstruct Hero { ... }\n```\n\nIf no table attribute, derive from struct name (Hero -\u003e heroes via snake_case + pluralize).\n\n### Field-Level Attributes\n```rust\n#[sqlmodel(primary_key)]           // Mark as PK\n#[sqlmodel(auto_increment)]        // Auto-generated value\n#[sqlmodel(column = \"hero_name\")]  // Custom column name\n#[sqlmodel(nullable)]              // Allow NULL (inferred from Option\u003cT\u003e)\n#[sqlmodel(unique)]                // UNIQUE constraint\n#[sqlmodel(foreign_key = \"teams.id\")]  // FK reference\n#[sqlmodel(default = \"0\")]         // DEFAULT value\n#[sqlmodel(sql_type = \"VARCHAR(100)\")] // Override SQL type\n#[sqlmodel(skip)]                  // Skip this field entirely\n#[sqlmodel(skip_insert)]           // Don't include in INSERT\n#[sqlmodel(skip_update)]           // Don't include in UPDATE\n```\n\n### Parsed Data Structures\n```rust\nstruct ModelDef {\n    name: Ident,\n    table_name: String,\n    table_alias: Option\u003cString\u003e,\n    fields: Vec\u003cFieldDef\u003e,\n    generics: Generics,\n}\n\nstruct FieldDef {\n    name: Ident,\n    column_name: String,\n    ty: Type,\n    sql_type: Option\u003cString\u003e,\n    nullable: bool,\n    primary_key: bool,\n    auto_increment: bool,\n    unique: bool,\n    foreign_key: Option\u003cString\u003e,\n    default: Option\u003cString\u003e,\n    skip: bool,\n    skip_insert: bool,\n    skip_update: bool,\n}\n```\n\n### Parsing Implementation\n```rust\nfn parse_model(input: \u0026DeriveInput) -\u003e Result\u003cModelDef, syn::Error\u003e {\n    let name = \u0026input.ident;\n    let generics = \u0026input.generics;\n    \n    // Parse struct-level attributes\n    let table_name = parse_table_name(\u0026input.attrs, name)?;\n    let table_alias = parse_table_alias(\u0026input.attrs)?;\n    \n    // Get struct fields\n    let fields = match \u0026input.data {\n        Data::Struct(data) =\u003e parse_fields(\u0026data.fields)?,\n        _ =\u003e return Err(syn::Error::new_spanned(input, \"Model can only be derived for structs\")),\n    };\n    \n    Ok(ModelDef { name: name.clone(), table_name, table_alias, fields, generics: generics.clone() })\n}\n\nfn parse_fields(fields: \u0026Fields) -\u003e Result\u003cVec\u003cFieldDef\u003e, syn::Error\u003e {\n    match fields {\n        Fields::Named(named) =\u003e {\n            named.named.iter().map(parse_field).collect()\n        }\n        _ =\u003e Err(syn::Error::new_spanned(fields, \"Model requires named fields\")),\n    }\n}\n\nfn parse_field(field: \u0026Field) -\u003e Result\u003cFieldDef, syn::Error\u003e {\n    let name = field.ident.clone().unwrap();\n    let ty = field.ty.clone();\n    \n    // Check if Option\u003cT\u003e\n    let nullable = is_option_type(\u0026ty);\n    \n    // Parse field attributes\n    let mut column_name = name.to_string();\n    let mut sql_type = None;\n    let mut primary_key = false;\n    // ... parse all attributes\n    \n    Ok(FieldDef { name, column_name, ty, sql_type, nullable, primary_key, ... })\n}\n```\n\n### Error Handling\nProvide helpful compile-time errors:\n- \"Model can only be derived for structs\"\n- \"Model requires named fields (not tuple struct)\"\n- \"Unknown attribute: #[sqlmodel(foo)]\"\n- \"Invalid foreign_key format, expected 'table.column'\"\n- \"Cannot use both skip and primary_key\"\n\n## Testing Requirements\n- Parse simple struct\n- Parse struct with all attributes\n- Error on enum\n- Error on tuple struct\n- Error on unknown attributes\n- Handle generics\n\n## Acceptance Criteria\n- [ ] Parse struct-level attributes correctly\n- [ ] Parse all field-level attributes\n- [ ] Infer nullable from Option\u003cT\u003e\n- [ ] Generate table name from struct name\n- [ ] Helpful error messages\n- [ ] Handle generic structs\n\n## Files to Modify\n- crates/sqlmodel-macros/src/lib.rs\n- crates/sqlmodel-macros/src/parse.rs (new)\n\n## Estimated Effort\n~300 lines of parsing code","status":"closed","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:22:00.814772761-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:57:42.899201053-05:00","closed_at":"2026-01-17T11:57:42.899201053-05:00","close_reason":"Complete: All acceptance criteria met - struct/field attribute parsing, Option\u003cT\u003e inference, table name derivation, helpful error messages, generic struct support. Code compiles and passes clippy.","dependencies":[{"issue_id":"sqlmodel_rust-t9h.1","depends_on_id":"sqlmodel_rust-t9h","type":"parent-child","created_at":"2026-01-17T11:22:00.816299006-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-t9h.2","title":"Macros: Generate Model trait implementation","description":"# Task: Generate Model Trait Implementation\n\n## Context\nAfter parsing the struct, generate the complete Model trait implementation with all required methods.\n\n## Required Code Generation\n\n### Constants\n```rust\nimpl Model for Hero {\n    const TABLE_NAME: \u0026'static str = \"heroes\";\n    const PRIMARY_KEY: \u0026'static [\u0026'static str] = \u0026[\"id\"];\n    const AUTO_INCREMENT: bool = true;\n    // ...\n}\n```\n\n### fields() Method\n```rust\nfn fields() -\u003e \u0026'static [FieldInfo] {\n    static FIELDS: \u0026[FieldInfo] = \u0026[\n        FieldInfo {\n            name: \"id\",\n            column_name: \"id\",\n            sql_type: SqlType::BigInt,\n            nullable: true,  // Option\u003ci64\u003e\n            primary_key: true,\n            auto_increment: true,\n            unique: false,\n            foreign_key: None,\n            default: None,\n            selectable: true,\n            insertable: false,  // auto_increment\n            updatable: false,   // primary_key\n            index: 0,\n        },\n        FieldInfo {\n            name: \"name\",\n            column_name: \"name\",\n            sql_type: SqlType::Text,\n            nullable: false,\n            // ...\n        },\n        // ...\n    ];\n    FIELDS\n}\n```\n\n### from_row() Method\n```rust\nfn from_row(row: \u0026Row) -\u003e Result\u003cSelf\u003e {\n    Ok(Self {\n        id: row.get_named_as(\"id\")?,\n        name: row.get_named_as(\"name\")?,\n        secret_name: row.get_named_as(\"secret_name\")?,\n        age: row.get_named_as(\"age\")?,\n        team_id: row.get_named_as(\"team_id\")?,\n    })\n}\n```\n\nHandle Option\u003cT\u003e fields:\n```rust\n// For Option\u003cT\u003e, get_named_as handles NULL -\u003e None automatically\nage: row.get_named_as::\u003cOption\u003ci32\u003e\u003e(\"age\")?,\n```\n\n### to_insert_values() Method\n```rust\nfn to_insert_values(\u0026self) -\u003e Vec\u003cValue\u003e {\n    vec![\n        // Skip id (auto_increment)\n        Value::from(\u0026self.name),\n        Value::from(\u0026self.secret_name),\n        Value::from(self.age),  // Option\u003ci32\u003e -\u003e Value::Null or Value::Integer\n        Value::from(self.team_id),\n    ]\n}\n```\n\n### to_update_values() Method\n```rust\nfn to_update_values(\u0026self) -\u003e Vec\u003cValue\u003e {\n    vec![\n        Value::from(\u0026self.name),\n        Value::from(\u0026self.secret_name),\n        Value::from(self.age),\n        Value::from(self.team_id),\n        // Include PK at end for WHERE clause\n        Value::from(self.id),\n    ]\n}\n```\n\n### primary_key_values() Method\n```rust\nfn primary_key_values(\u0026self) -\u003e Vec\u003cValue\u003e {\n    vec![Value::from(self.id)]\n}\n```\n\n### Column Name Methods\n```rust\nfn insert_columns() -\u003e \u0026'static [\u0026'static str] {\n    \u0026[\"name\", \"secret_name\", \"age\", \"team_id\"]\n}\n\nfn update_columns() -\u003e \u0026'static [\u0026'static str] {\n    \u0026[\"name\", \"secret_name\", \"age\", \"team_id\"]\n}\n\nfn columns() -\u003e \u0026'static [\u0026'static str] {\n    \u0026[\"id\", \"name\", \"secret_name\", \"age\", \"team_id\"]\n}\n```\n\n### Code Generation Using quote!\n```rust\nfn generate_model_impl(model: \u0026ModelDef) -\u003e TokenStream {\n    let name = \u0026model.name;\n    let table_name = \u0026model.table_name;\n    let pk_cols = model.primary_key_columns();\n    \n    let fields_code = generate_fields_static(\u0026model.fields);\n    let from_row_code = generate_from_row(\u0026model.fields);\n    let to_insert_code = generate_to_insert(\u0026model.fields);\n    // ...\n    \n    quote! {\n        impl ::sqlmodel::Model for #name {\n            const TABLE_NAME: \u0026'static str = #table_name;\n            const PRIMARY_KEY: \u0026'static [\u0026'static str] = \u0026[#(#pk_cols),*];\n            // ...\n            \n            fn fields() -\u003e \u0026'static [::sqlmodel::FieldInfo] {\n                #fields_code\n            }\n            \n            fn from_row(row: \u0026::sqlmodel::Row) -\u003e ::sqlmodel::Result\u003cSelf\u003e {\n                #from_row_code\n            }\n            \n            fn to_insert_values(\u0026self) -\u003e Vec\u003c::sqlmodel::Value\u003e {\n                #to_insert_code\n            }\n            \n            // ...\n        }\n    }\n}\n```\n\n## Testing Requirements\n- Compile simple Model derive\n- Verify constants are correct\n- Verify from_row handles all types\n- Verify to_insert excludes auto_increment\n- Verify to_update includes all editable fields\n- Test with Option\u003cT\u003e fields\n- Test with custom column names\n\n## Acceptance Criteria\n- [ ] Generate complete Model impl\n- [ ] Constants match struct/attributes\n- [ ] from_row correctly converts all types\n- [ ] to_insert_values respects skip_insert\n- [ ] to_update_values respects skip_update\n- [ ] Column methods return correct names\n- [ ] Works with nested Option types\n\n## Dependencies\n- sqlmodel_rust-t9h.1 (Parse struct and attributes)\n\n## Files to Modify\n- crates/sqlmodel-macros/src/lib.rs\n- crates/sqlmodel-macros/src/generate.rs (new)\n\n## Estimated Effort\n~350 lines of code generation","status":"closed","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:22:22.129291504-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:58:57.669989067-05:00","closed_at":"2026-01-17T11:58:57.669989067-05:00","close_reason":"Complete: Model trait implementation generation already done in lib.rs - generates TABLE_NAME, PRIMARY_KEY constants, fields(), to_row(), from_row(), primary_key_value(), is_new() methods per trait definition. Extra methods in task description are not required by Model trait interface.","dependencies":[{"issue_id":"sqlmodel_rust-t9h.2","depends_on_id":"sqlmodel_rust-t9h","type":"parent-child","created_at":"2026-01-17T11:22:22.130468511-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-t9h.2","depends_on_id":"sqlmodel_rust-t9h.1","type":"blocks","created_at":"2026-01-17T11:22:22.132436607-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-t9h.3","title":"Macros: Infer SQL types from Rust types","description":"# Task: Infer SQL Types from Rust Types\n\n## Context\nWhen no explicit sql_type attribute is provided, automatically infer the correct SQL type from the Rust type. This must handle primitives, strings, optionals, and common library types.\n\n## Type Mapping Rules\n\n### Primitive Types\n```\nbool        -\u003e Boolean\ni8          -\u003e TinyInt\ni16         -\u003e SmallInt\ni32         -\u003e Integer\ni64         -\u003e BigInt\nu8          -\u003e SmallInt (no unsigned in SQL)\nu16         -\u003e Integer\nu32         -\u003e BigInt\nu64         -\u003e BigInt (potential overflow warning)\nf32         -\u003e Real\nf64         -\u003e Double\n```\n\n### String Types\n```\nString      -\u003e Text\n\u0026str        -\u003e Text (via String)\nchar        -\u003e Char(1)\n```\n\n### Binary Types\n```\nVec\u003cu8\u003e     -\u003e Blob\n\u0026[u8]       -\u003e Blob (via Vec\u003cu8\u003e)\n[u8; N]     -\u003e Blob\n```\n\n### Optional Types\n```\nOption\u003cT\u003e   -\u003e T's SQL type (with nullable: true)\nOption\u003cOption\u003cT\u003e\u003e -\u003e Error: nested optionals not supported\n```\n\n### Common Library Types (feature-gated)\n```\n// chrono\nchrono::NaiveDate       -\u003e Date\nchrono::NaiveTime       -\u003e Time\nchrono::NaiveDateTime   -\u003e DateTime\nchrono::DateTime\u003cUtc\u003e   -\u003e TimestampTz\nchrono::DateTime\u003cLocal\u003e -\u003e TimestampTz\n\n// uuid\nuuid::Uuid              -\u003e Uuid\n\n// rust_decimal\nrust_decimal::Decimal   -\u003e Numeric(38, 18)\n\n// serde_json\nserde_json::Value       -\u003e Json\n\n// time (alternative to chrono)\ntime::Date              -\u003e Date\ntime::Time              -\u003e Time\ntime::PrimitiveDateTime -\u003e DateTime\ntime::OffsetDateTime    -\u003e TimestampTz\n\n// bytes\nbytes::Bytes            -\u003e Blob\nbytes::BytesMut         -\u003e Blob\n```\n\n### Array Types (PostgreSQL only)\n```\nVec\u003cT\u003e      -\u003e Array(T's SQL type)  // when enabled\n```\n\n## Implementation\n\n### Type Inference Function\n```rust\nfn infer_sql_type(ty: \u0026Type) -\u003e Result\u003cSqlType, syn::Error\u003e {\n    // Handle Option\u003cT\u003e\n    if let Some(inner) = extract_option_inner(ty) {\n        return infer_sql_type(\u0026inner);  // Nullable set separately\n    }\n    \n    // Handle Vec\u003cT\u003e\n    if let Some(inner) = extract_vec_inner(ty) {\n        if is_u8_type(\u0026inner) {\n            return Ok(SqlType::Blob);\n        }\n        // For other Vec\u003cT\u003e, could be Array type (feature-gated)\n        #[cfg(feature = \"postgres-arrays\")]\n        return Ok(SqlType::Array(Box::new(infer_sql_type(\u0026inner)?)));\n        \n        return Err(syn::Error::new_spanned(ty, \"Vec\u003cT\u003e not supported, use Vec\u003cu8\u003e for binary data\"));\n    }\n    \n    // Match primitive types\n    match type_to_string(ty).as_str() {\n        \"bool\" =\u003e Ok(SqlType::Boolean),\n        \"i8\" =\u003e Ok(SqlType::TinyInt),\n        \"i16\" =\u003e Ok(SqlType::SmallInt),\n        \"i32\" =\u003e Ok(SqlType::Integer),\n        \"i64\" =\u003e Ok(SqlType::BigInt),\n        \"f32\" =\u003e Ok(SqlType::Real),\n        \"f64\" =\u003e Ok(SqlType::Double),\n        \"String\" | \"\u0026str\" =\u003e Ok(SqlType::Text),\n        \"char\" =\u003e Ok(SqlType::Char(1)),\n        \n        // Library types (check if feature enabled)\n        \"NaiveDate\" | \"chrono::NaiveDate\" =\u003e Ok(SqlType::Date),\n        \"NaiveDateTime\" | \"chrono::NaiveDateTime\" =\u003e Ok(SqlType::DateTime),\n        \"Uuid\" | \"uuid::Uuid\" =\u003e Ok(SqlType::Uuid),\n        // ...\n        \n        _ =\u003e Err(syn::Error::new_spanned(\n            ty,\n            format!(\"Cannot infer SQL type for '{}'. Use #[sqlmodel(sql_type = \\\"...\\\")] to specify.\", type_to_string(ty))\n        )),\n    }\n}\n\nfn extract_option_inner(ty: \u0026Type) -\u003e Option\u003cType\u003e {\n    if let Type::Path(type_path) = ty {\n        let segment = type_path.path.segments.last()?;\n        if segment.ident == \"Option\" {\n            if let PathArguments::AngleBracketed(args) = \u0026segment.arguments {\n                if let Some(GenericArgument::Type(inner)) = args.args.first() {\n                    return Some(inner.clone());\n                }\n            }\n        }\n    }\n    None\n}\n```\n\n### Override with Attribute\n```rust\n// Even if inference works, allow explicit override\n#[sqlmodel(sql_type = \"VARCHAR(100)\")]\nname: String,\n\n#[sqlmodel(sql_type = \"NUMERIC(10,2)\")]\nprice: f64,\n```\n\n## Testing Requirements\n- All primitives map correctly\n- Option\u003cT\u003e sets nullable + inner type\n- Vec\u003cu8\u003e -\u003e Blob\n- Custom types error with helpful message\n- Override attribute takes precedence\n- Feature-gated types only work with feature\n\n## Acceptance Criteria\n- [ ] All primitive types inferred correctly\n- [ ] Option\u003cT\u003e handled (nullable + type)\n- [ ] Common library types supported\n- [ ] Helpful errors for unknown types\n- [ ] Override via sql_type attribute\n- [ ] No panics for any input type\n\n## Files to Modify\n- crates/sqlmodel-macros/src/infer.rs (new)\n\n## Estimated Effort\n~200 lines of type inference code","status":"closed","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:22:46.317868455-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T12:18:52.209084404-05:00","closed_at":"2026-01-17T12:18:52.209084404-05:00","close_reason":"Complete: Implemented enhanced SQL type inference in infer.rs, fixed to_snake_case and pluralize test failures","dependencies":[{"issue_id":"sqlmodel_rust-t9h.3","depends_on_id":"sqlmodel_rust-t9h","type":"parent-child","created_at":"2026-01-17T11:22:46.322467136-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-t9h.3","depends_on_id":"sqlmodel_rust-t9h.1","type":"blocks","created_at":"2026-01-17T11:22:46.326633011-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-t9h.4","title":"Macros: Compile-time validation and error messages","description":"# Task: Compile-Time Validation and Error Messages\n\n## Context\nProc macros should catch configuration errors at compile time with clear, actionable error messages. This improves developer experience significantly.\n\n## Validations to Implement\n\n### Struct-Level Validations\n1. **Must be a struct**: Error on enum, union\n2. **Named fields required**: Error on tuple struct\n3. **At least one field required**: Error on empty struct\n4. **Table name valid**: No SQL injection characters\n\n### Field-Level Validations\n1. **Primary key exists**: Warn if no primary_key field (unless skip_pk_check)\n2. **Auto-increment requires primary_key**: Error if auto_increment without primary_key\n3. **Conflicting attributes**: Error on skip + primary_key, skip + unique, etc.\n4. **Foreign key format**: Must be \"table.column\"\n5. **Valid SQL type**: If specified, must be parseable\n6. **No duplicate column names**: Error if two fields map to same column\n\n### Type Validations\n1. **Supported type**: Error with suggestion for unsupported types\n2. **No nested Option**: Option\u003cOption\u003cT\u003e\u003e is ambiguous\n3. **No reference types**: \u0026T not supported (use owned types)\n\n### Error Message Format\n```rust\nerror: Model requires at least one field marked as #[sqlmodel(primary_key)]\n  --\u003e src/models.rs:5:1\n   |\n 5 | struct Hero {\n   | ^^^^^^^^^^^\n   |\n   = help: add #[sqlmodel(primary_key)] to a field, or use #[sqlmodel(skip_pk_check)] if intentional\n```\n\n```rust\nerror: cannot use both #[sqlmodel(skip)] and #[sqlmodel(primary_key)] on the same field\n  --\u003e src/models.rs:8:5\n   |\n 8 |     #[sqlmodel(skip, primary_key)]\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: skipped fields are excluded from all database operations\n```\n\n```rust\nerror: foreign_key must be in format \"table.column\", got \"teams\"\n  --\u003e src/models.rs:12:5\n   |\n12 |     #[sqlmodel(foreign_key = \"teams\")]\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: use #[sqlmodel(foreign_key = \"teams.id\")]\n```\n\n### Implementation\n```rust\nfn validate_model(model: \u0026ModelDef) -\u003e Result\u003c(), syn::Error\u003e {\n    let mut errors = Vec::new();\n    \n    // Check for primary key\n    let has_pk = model.fields.iter().any(|f| f.primary_key);\n    if !has_pk \u0026\u0026 !model.skip_pk_check {\n        errors.push(syn::Error::new(\n            model.name.span(),\n            \"Model requires at least one field marked as #[sqlmodel(primary_key)]\"\n        ));\n    }\n    \n    // Check each field\n    for field in \u0026model.fields {\n        validate_field(field, \u0026mut errors);\n    }\n    \n    // Check for duplicate column names\n    let mut seen_columns = HashSet::new();\n    for field in \u0026model.fields {\n        if !field.skip \u0026\u0026 !seen_columns.insert(\u0026field.column_name) {\n            errors.push(syn::Error::new(\n                field.name.span(),\n                format!(\"duplicate column name: {}\", field.column_name)\n            ));\n        }\n    }\n    \n    // Combine all errors\n    if errors.is_empty() {\n        Ok(())\n    } else {\n        let mut combined = errors.remove(0);\n        for err in errors {\n            combined.combine(err);\n        }\n        Err(combined)\n    }\n}\n\nfn validate_field(field: \u0026FieldDef, errors: \u0026mut Vec\u003csyn::Error\u003e) {\n    // Conflicting attributes\n    if field.skip \u0026\u0026 field.primary_key {\n        errors.push(syn::Error::new(\n            field.name.span(),\n            \"cannot use both #[sqlmodel(skip)] and #[sqlmodel(primary_key)]\"\n        ));\n    }\n    \n    if field.auto_increment \u0026\u0026 !field.primary_key {\n        errors.push(syn::Error::new(\n            field.name.span(),\n            \"auto_increment requires primary_key\"\n        ));\n    }\n    \n    // Foreign key format\n    if let Some(fk) = \u0026field.foreign_key {\n        if !fk.contains('.') {\n            errors.push(syn::Error::new(\n                field.name.span(),\n                format!(\"foreign_key must be in format \\\"table.column\\\", got \\\"{}\\\"\", fk)\n            ));\n        }\n    }\n}\n```\n\n## Testing Requirements\n- Each validation has a compile-fail test\n- Error messages are clear and actionable\n- Multiple errors reported together\n- Span points to correct location\n\n## Acceptance Criteria\n- [ ] All validations implemented\n- [ ] Clear error messages with spans\n- [ ] Helpful suggestions in errors\n- [ ] Multiple errors combined\n- [ ] Compile-fail tests for each case\n\n## Files to Modify\n- crates/sqlmodel-macros/src/validate.rs (new)\n\n## Estimated Effort\n~200 lines of validation code","status":"closed","priority":0,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:23:09.275026279-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T12:25:30.748462977-05:00","closed_at":"2026-01-17T12:25:30.748462977-05:00","close_reason":"Complete: Implemented comprehensive compile-time validation in validate.rs with struct-level, field-level, and type validations. Includes checks for empty structs, invalid table names, duplicate columns, auto_increment without primary_key, nested Option, reference types, raw pointers, and skip attribute conflicts.","dependencies":[{"issue_id":"sqlmodel_rust-t9h.4","depends_on_id":"sqlmodel_rust-t9h","type":"parent-child","created_at":"2026-01-17T11:23:09.276828994-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-t9h.4","depends_on_id":"sqlmodel_rust-t9h.1","type":"blocks","created_at":"2026-01-17T11:23:09.27838283-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-t9h.4","depends_on_id":"sqlmodel_rust-t9h.3","type":"blocks","created_at":"2026-01-17T11:23:09.280115914-05:00","created_by":"Dicklesworthstone"}]}
{"id":"sqlmodel_rust-t9h.5","title":"Macros: Unit and integration tests","description":"# Task: Macro Unit and Integration Tests\n\n## Context\nTest the Model derive macro thoroughly using both compile-pass and compile-fail tests.\n\n## Test Categories\n\n### 1. Basic Derive Tests\n```rust\n#[derive(Model)]\nstruct SimpleModel {\n    #[sqlmodel(primary_key)]\n    id: i64,\n    name: String,\n}\n\n#[test]\nfn test_simple_model() {\n    assert_eq!(SimpleModel::TABLE_NAME, \"simple_models\");\n    assert_eq!(SimpleModel::PRIMARY_KEY, \u0026[\"id\"]);\n    assert_eq!(SimpleModel::fields().len(), 2);\n}\n```\n\n### 2. Attribute Tests\n```rust\n#[derive(Model)]\n#[sqlmodel(table = \"heroes\")]\nstruct Hero {\n    #[sqlmodel(primary_key, auto_increment)]\n    id: Option\u003ci64\u003e,\n    \n    #[sqlmodel(column = \"hero_name\", unique)]\n    name: String,\n    \n    #[sqlmodel(nullable)]\n    age: Option\u003ci32\u003e,\n    \n    #[sqlmodel(foreign_key = \"teams.id\")]\n    team_id: Option\u003ci64\u003e,\n}\n\n#[test]\nfn test_hero_attributes() {\n    assert_eq!(Hero::TABLE_NAME, \"heroes\");\n    \n    let id_field = Hero::field(\"id\").unwrap();\n    assert!(id_field.primary_key);\n    assert!(id_field.auto_increment);\n    \n    let name_field = Hero::field(\"name\").unwrap();\n    assert_eq!(name_field.column_name, \"hero_name\");\n    assert!(name_field.unique);\n}\n```\n\n### 3. from_row Tests\n```rust\n#[test]\nfn test_from_row() {\n    let row = Row::new(\n        vec![Value::BigInt(1), Value::Text(\"Spider-Man\".into())],\n        Arc::new(ColumnInfo::new(\u0026[\"id\", \"name\"])),\n    );\n    \n    let model = SimpleModel::from_row(\u0026row).unwrap();\n    assert_eq!(model.id, 1);\n    assert_eq!(model.name, \"Spider-Man\");\n}\n\n#[test]\nfn test_from_row_with_null() {\n    let row = Row::new(\n        vec![Value::BigInt(1), Value::Text(\"Spider-Man\".into()), Value::Null],\n        Arc::new(ColumnInfo::new(\u0026[\"id\", \"name\", \"age\"])),\n    );\n    \n    let hero = Hero::from_row(\u0026row).unwrap();\n    assert_eq!(hero.age, None);\n}\n```\n\n### 4. to_values Tests\n```rust\n#[test]\nfn test_to_insert_values() {\n    let hero = Hero {\n        id: None,\n        name: \"Spider-Man\".into(),\n        age: Some(25),\n        team_id: None,\n    };\n    \n    let values = hero.to_insert_values();\n    // id is auto_increment, so not included\n    assert_eq!(values.len(), 3);\n    assert_eq!(values[0], Value::Text(\"Spider-Man\".into()));\n    assert_eq!(values[1], Value::Integer(25));\n    assert_eq!(values[2], Value::Null);\n}\n```\n\n### 5. Compile-Fail Tests (using trybuild)\n```rust\n// tests/compile_fail/enum_not_supported.rs\n#[derive(Model)]\nenum NotAStruct {\n    A,\n    B,\n}\n\n// tests/compile_fail/missing_primary_key.rs\n#[derive(Model)]\nstruct NoPrimaryKey {\n    name: String,\n}\n\n// tests/compile_fail/conflicting_attributes.rs\n#[derive(Model)]\nstruct Conflict {\n    #[sqlmodel(skip, primary_key)]\n    id: i64,\n}\n```\n\n### 6. Complex Type Tests\n```rust\n#[derive(Model)]\nstruct ComplexTypes {\n    #[sqlmodel(primary_key)]\n    id: i64,\n    \n    // All numeric types\n    tiny: i8,\n    small: i16,\n    int: i32,\n    big: i64,\n    float: f32,\n    double: f64,\n    \n    // Optional types\n    maybe_int: Option\u003ci32\u003e,\n    maybe_string: Option\u003cString\u003e,\n    \n    // Binary\n    data: Vec\u003cu8\u003e,\n}\n```\n\n## Test Infrastructure\n```rust\n// In tests/macro_tests.rs\nuse sqlmodel::Model;\nuse sqlmodel_core::{Row, Value, ColumnInfo};\n\nmod fixtures {\n    pub fn simple_row() -\u003e Row { ... }\n    pub fn hero_row() -\u003e Row { ... }\n}\n```\n\n## Acceptance Criteria\n- [ ] All basic derive cases tested\n- [ ] All attributes tested individually\n- [ ] from_row tested with various types\n- [ ] to_values tested with various types\n- [ ] Compile-fail tests for all error cases\n- [ ] Tests pass with cargo test\n\n## Files to Create\n- crates/sqlmodel-macros/tests/derive_tests.rs\n- crates/sqlmodel-macros/tests/compile_fail/*.rs\n\n## Estimated Effort\n~400 lines of test code","status":"open","priority":1,"issue_type":"task","owner":"jeff141421@gmail.com","created_at":"2026-01-17T11:23:28.88287807-05:00","created_by":"Dicklesworthstone","updated_at":"2026-01-17T11:23:28.88287807-05:00","dependencies":[{"issue_id":"sqlmodel_rust-t9h.5","depends_on_id":"sqlmodel_rust-t9h","type":"parent-child","created_at":"2026-01-17T11:23:28.884509442-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-t9h.5","depends_on_id":"sqlmodel_rust-t9h.2","type":"blocks","created_at":"2026-01-17T11:23:28.886331073-05:00","created_by":"Dicklesworthstone"},{"issue_id":"sqlmodel_rust-t9h.5","depends_on_id":"sqlmodel_rust-t9h.4","type":"blocks","created_at":"2026-01-17T11:23:28.887770975-05:00","created_by":"Dicklesworthstone"}]}
